<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang 高性能网络库 evio 源码解析 | 徐旭 的博客</title><meta name=keywords content="Go,Open Source"><meta name=description content="阅读前提：了解 epoll
 evio 是一个基于事件驱动的网络框架，它非常轻量而且相比 Go net 标准库更快。其底层使用epoll 和 kqueue 系统调度实现。
 原理 evio 是 Reactor 模式的简单实现。Reactor 本质就是“non-blocking IO + IO multiplexing”，通过非阻塞IO+ IO 多路复用来处理并发。程序运行一个或者多个事件循环，通过在事件循环中注册回调的方式实现业务逻辑。
evio 将所有文件描述符设为非阻塞，并注册到事件循环（ epoll / kqueue ）中。相较于传统的 per thread per connection 的处理方法，线程使用更少，线程资源利用率更高。
evio 需要在服务启动前，注册回调函数，当事件循环中有事件到来时，会调用回调函数处理。
使用示例 先从一个简单的 echo server 的例子来了解 evio 。
package main import ( &#34;flag&#34; &#34;fmt&#34; &#34;log&#34; &#34;strings&#34; &#34;github.com/tidwall/evio&#34; ) func main() { var port int var loops int var udp bool var trace bool var reuseport bool var stdlib bool flag."><meta name=author content="徐旭"><link rel=canonical href=https://mogutou.xyz/posts/open-source/evio-code/><link crossorigin=anonymous href=/assets/css/stylesheet.min.04512c372388e08b5118f5b117b2d3efef4ddae52017e16085c8d8d4e361c43d.css integrity="sha256-BFEsNyOI4ItRGPWxF7LT7+9N2uUgF+FghcjY1ONhxD0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://mogutou.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mogutou.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mogutou.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://mogutou.xyz/apple-touch-icon.png><link rel=mask-icon href=https://mogutou.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CS73EMP38T"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-CS73EMP38T')</script><script data-ad-client=ca-pub-9617847803031506 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><meta property="og:title" content="Golang 高性能网络库 evio 源码解析"><meta property="og:description" content="阅读前提：了解 epoll
 evio 是一个基于事件驱动的网络框架，它非常轻量而且相比 Go net 标准库更快。其底层使用epoll 和 kqueue 系统调度实现。
 原理 evio 是 Reactor 模式的简单实现。Reactor 本质就是“non-blocking IO + IO multiplexing”，通过非阻塞IO+ IO 多路复用来处理并发。程序运行一个或者多个事件循环，通过在事件循环中注册回调的方式实现业务逻辑。
evio 将所有文件描述符设为非阻塞，并注册到事件循环（ epoll / kqueue ）中。相较于传统的 per thread per connection 的处理方法，线程使用更少，线程资源利用率更高。
evio 需要在服务启动前，注册回调函数，当事件循环中有事件到来时，会调用回调函数处理。
使用示例 先从一个简单的 echo server 的例子来了解 evio 。
package main import ( &#34;flag&#34; &#34;fmt&#34; &#34;log&#34; &#34;strings&#34; &#34;github.com/tidwall/evio&#34; ) func main() { var port int var loops int var udp bool var trace bool var reuseport bool var stdlib bool flag."><meta property="og:type" content="article"><meta property="og:url" content="https://mogutou.xyz/posts/open-source/evio-code/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-06T11:22:38+08:00"><meta property="article:modified_time" content="2019-08-06T11:22:38+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang 高性能网络库 evio 源码解析"><meta name=twitter:description content="阅读前提：了解 epoll
 evio 是一个基于事件驱动的网络框架，它非常轻量而且相比 Go net 标准库更快。其底层使用epoll 和 kqueue 系统调度实现。
 原理 evio 是 Reactor 模式的简单实现。Reactor 本质就是“non-blocking IO + IO multiplexing”，通过非阻塞IO+ IO 多路复用来处理并发。程序运行一个或者多个事件循环，通过在事件循环中注册回调的方式实现业务逻辑。
evio 将所有文件描述符设为非阻塞，并注册到事件循环（ epoll / kqueue ）中。相较于传统的 per thread per connection 的处理方法，线程使用更少，线程资源利用率更高。
evio 需要在服务启动前，注册回调函数，当事件循环中有事件到来时，会调用回调函数处理。
使用示例 先从一个简单的 echo server 的例子来了解 evio 。
package main import ( &#34;flag&#34; &#34;fmt&#34; &#34;log&#34; &#34;strings&#34; &#34;github.com/tidwall/evio&#34; ) func main() { var port int var loops int var udp bool var trace bool var reuseport bool var stdlib bool flag."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mogutou.xyz/posts/"},{"@type":"ListItem","position":2,"name":"Golang 高性能网络库 evio 源码解析","item":"https://mogutou.xyz/posts/open-source/evio-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang 高性能网络库 evio 源码解析","name":"Golang 高性能网络库 evio 源码解析","description":"阅读前提：了解 epoll\n evio 是一个基于事件驱动的网络框架，它非常轻量而且相比 Go net 标准库更快。其底层使用epoll 和 kqueue 系统调度实现。\n 原理 evio 是 Reactor 模式的简单实现。Reactor 本质就是“non-blocking IO + IO multiplexing”，通过非阻塞IO+ IO 多路复用来处理并发。程序运行一个或者多个事件循环，通过在事件循环中注册回调的方式实现业务逻辑。\nevio 将所有文件描述符设为非阻塞，并注册到事件循环（ epoll / kqueue ）中。相较于传统的 per thread per connection 的处理方法，线程使用更少，线程资源利用率更高。\nevio 需要在服务启动前，注册回调函数，当事件循环中有事件到来时，会调用回调函数处理。\n使用示例 先从一个简单的 echo server 的例子来了解 evio 。\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/tidwall/evio\u0026#34; ) func main() { var port int var loops int var udp bool var trace bool var reuseport bool var stdlib bool flag.","keywords":["Go","Open Source"],"articleBody":" 阅读前提：了解 epoll\n evio 是一个基于事件驱动的网络框架，它非常轻量而且相比 Go net 标准库更快。其底层使用epoll 和 kqueue 系统调度实现。\n 原理 evio 是 Reactor 模式的简单实现。Reactor 本质就是“non-blocking IO + IO multiplexing”，通过非阻塞IO+ IO 多路复用来处理并发。程序运行一个或者多个事件循环，通过在事件循环中注册回调的方式实现业务逻辑。\nevio 将所有文件描述符设为非阻塞，并注册到事件循环（ epoll / kqueue ）中。相较于传统的 per thread per connection 的处理方法，线程使用更少，线程资源利用率更高。\nevio 需要在服务启动前，注册回调函数，当事件循环中有事件到来时，会调用回调函数处理。\n使用示例 先从一个简单的 echo server 的例子来了解 evio 。\npackage main import ( \"flag\" \"fmt\" \"log\" \"strings\" \"github.com/tidwall/evio\" ) func main() { var port int var loops int var udp bool var trace bool var reuseport bool var stdlib bool flag.IntVar(\u0026port, \"port\", 5000, \"server port\") flag.BoolVar(\u0026udp, \"udp\", false, \"listen on udp\") flag.BoolVar(\u0026reuseport, \"reuseport\", false, \"reuseport (SO_REUSEPORT)\") flag.BoolVar(\u0026trace, \"trace\", false, \"print packets to console\") flag.IntVar(\u0026loops, \"loops\", 0, \"num loops\") flag.BoolVar(\u0026stdlib, \"stdlib\", false, \"use stdlib\") flag.Parse() var events evio.Events events.NumLoops = loops events.Serving = func(srv evio.Server) (action evio.Action) { log.Printf(\"echo server started on port %d (loops: %d)\", port, srv.NumLoops) if reuseport { log.Printf(\"reuseport\") } if stdlib { log.Printf(\"stdlib\") } return } events.Data = func(c evio.Conn, in []byte) (out []byte, action evio.Action) { if trace { log.Printf(\"%s\", strings.TrimSpace(string(in))) } out = in return } scheme := \"tcp\" if udp { scheme = \"udp\" } if stdlib { scheme += \"-net\" } log.Fatal(evio.Serve(events, fmt.Sprintf(\"%s://:%d?reuseport=%t\", scheme, port, reuseport))) } 上面的例子主要就是注册了两个回调函数： events.Serving 和 events.Data 。\n当 server 启动时，会来执行注册的 events.Serving 回调函数； 当有数据到来时，执行 events.Data 回调函数。\n程序最后调用 evio.Serve 方法开启事件循环，程序在此处不断循环检测是否有事件发生并处理（有数据到来，有数据要发送…)。\nevio 都是通过回调函数来执行业务逻辑的。 当客户端有数据发送过来时，调用用户注册的 events.Data 函数。\n需要发送数据给客户端时，只可以通过注册的回调函数的返回值来返回，evio 框架来负责发送（有bug）。\n回调函数的返回值主要有两个 out []byte, action evio.Action , out 就是需要发送给客户端的， Action 就是返回一些状态，用来关闭连接，或者服务器退出啥的操作。主要状态如下：\nconst ( // None indicates that no action should occur following an event. \tNone Action = iota // Detach detaches a connection. Not available for UDP connections. \tDetach // Close closes the connection. \tClose // Shutdown shutdowns the server. \tShutdown ) evio 的事件循环 evio.Serve 我们先来看下 evio.Serve 方法的实现\nfunc Serve(events Events, addr ...string) error { var lns []*listener defer func() { // 这个函数如果推出，需要关闭所有 listener \tfor _, ln := range lns { ln.close() } }() var stdlib bool // 可以选择使用 stdlib（stdlib 主要是为了支持 非 *unix 平台） \tfor _, addr := range addr { // 生成 listener \tvar ln listener var stdlibt bool ln.network, ln.addr, ln.opts, stdlibt = parseAddr(addr) if stdlibt { stdlib = true } if ln.network == \"unix\" { os.RemoveAll(ln.addr) } var err error if ln.network == \"udp\" { if ln.opts.reusePort { ln.pconn, err = reuseportListenPacket(ln.network, ln.addr) } else { ln.pconn, err = net.ListenPacket(ln.network, ln.addr) } } else { if ln.opts.reusePort { ln.ln, err = reuseportListen(ln.network, ln.addr) } else { ln.ln, err = net.Listen(ln.network, ln.addr) } } if err != nil { return err } if ln.pconn != nil { ln.lnaddr = ln.pconn.LocalAddr() } else { ln.lnaddr = ln.ln.Addr() } if !stdlib { if err := ln.system(); err != nil { return err } } lns = append(lns, \u0026ln) } if stdlib { return stdserve(events, lns) // 使用 std net 库 启动server \t} return serve(events, lns) // 使用 epoll or kqueue 启动server } 从 Serve 函数签名中可以看出 evio 是支持绑定多地址监听的\nfunc Serve(events Events, addr ...string) error 使用方式如下：\nevio.Serve(events, \"tcp://localhost:5000\", \"tcp://192.168.0.10:5001\"); 现在我们看看 evio 的核心部分: serve(events, lns) ，这里会启动 evio 的 sever 。\nfunc serve(events Events, listeners []*listener) error { numLoops := events.NumLoops\t// 确定启动的事件循环数量 \tif numLoops  0 { if numLoops == 0 { numLoops = 1 } else { numLoops = runtime.NumCPU() } } s := \u0026server{} s.events = events s.lns = listeners s.cond = sync.NewCond(\u0026sync.Mutex{}) s.balance = events.LoadBalance s.tch = make(chan time.Duration) //println(\"-- server starting\") \tif s.events.Serving != nil {\t// 如果注册了回调函数，就执行 \tvar svr Server svr.NumLoops = numLoops svr.Addrs = make([]net.Addr, len(listeners)) for i, ln := range listeners { svr.Addrs[i] = ln.lnaddr } action := s.events.Serving(svr) switch action { case None: case Shutdown: return nil } } defer func() {\t// server 退出后的清理工作 \t// wait on a signal for shutdown \ts.waitForShutdown() // notify all loops to close by closing all listeners \tfor _, l := range s.loops { l.poll.Trigger(errClosing) } // wait on all loops to complete reading events \ts.wg.Wait() // close loops and all outstanding connections \tfor _, l := range s.loops { for _, c := range l.fdconns { loopCloseConn(s, l, c, nil) } l.poll.Close() } //println(\"-- server stopped\") \t}() // create loops locally and bind the listeners. \tfor i := 0; i numLoops; i++ { l := \u0026loop{ idx: i, poll: internal.OpenPoll(), packet: make([]byte, 0xFFFF), // event loop 的 read 缓冲区 \tfdconns: make(map[int]*conn), } for _, ln := range listeners { l.poll.AddRead(ln.fd)\t// 将 fd 注册到 epoll 中并监听可读事件 \t} s.loops = append(s.loops, l) } // start loops in background \ts.wg.Add(len(s.loops)) for _, l := range s.loops { // 启动所有的 event loop \tgo loopRun(s, l) } return nil } serve 主要做这些事：\n 根据配置启动指定数量的 event loop，如果传入配置的 loop 数量为 0 则设置启动一个事件循环，如果传入配置小于 0 则设置为运行平台的CPU核心数量 如果设置了回调函数 events.Serving ，运行它 按照指定 event loop 数量，创建 epoll 句柄生成 loop ，并将所有的 listener 注册到 epoll 监听可读事件（有客户端连接） 启动所有事件循环(一个事件循环一个 goroutine)  需要注意的是，evio 将所有的 listener 的 fd 在每一个事件循环的 epoll 中都注册了。也就是说，如果有三个事件循环，一个 listener ，那么这个 listener 的 fd 会注册到三个 epoll 中。这就会出现 epoll 的惊群现象，感兴趣的可以自己搜索了解下。\nevio 当一个新连接到来时，所有的事件循环都会唤醒，但是最终只有一个线程可以accept调用返回成功，其他线程（协程）的accept函数调用返回EAGAIN错误 。\nloopRun 下面我们看看 loopRun 的内部实现\nfunc loopRun(s *server, l *loop) { defer func() { //fmt.Println(\"-- loop stopped --\", l.idx) \ts.signalShutdown() s.wg.Done() }() if l.idx == 0 \u0026\u0026 s.events.Tick != nil { go loopTicker(s, l) } //fmt.Println(\"-- loop started --\", l.idx) \tl.poll.Wait(func(fd int, note interface{}) error { if fd == 0 { return loopNote(s, l, note) } c := l.fdconns[fd] switch { case c == nil: return loopAccept(s, l, fd) case !c.opened: return loopOpened(s, l, c) case len(c.out)  0: return loopWrite(s, l, c) case c.action != None: return loopAction(s, l, c) default: return loopRead(s, l, c) } }) } l.poll.Wait 传入一个回调函数作为参数，当 epoll 收到事件通知时，会执行这个回调函数。\n在这个函数中接受客户端连接，读取客户端数据，调用客户回调函数处理业务逻辑…\n我们先来看下 poll.Wait 的内部实现，再看看 loopAccept，loopOpened，loopWrite 等函数。 loopRun 方法中最重要的就是 poll.Wait ，我们看看 Linux 下 epoll 的实现\nfunc (p *Poll) Wait(iter func(fd int, note interface{}) error) error { events := make([]syscall.EpollEvent, 64) for { n, err := syscall.EpollWait(p.fd, events, -1) if err != nil \u0026\u0026 err != syscall.EINTR { return err } if err := p.notes.ForEach(func(note interface{}) error { return iter(0, note) }); err != nil { return err } for i := 0; i n; i++ { if fd := int(events[i].Fd); fd != p.wfd { if err := iter(fd, nil); err != nil { return err } } else { } } } } 这个函数中是一个死循环，程序会阻塞在此处等待 epoll 的”通知“，然后处理就绪的 fd （读取/发送数据、执行用户注册的回调函数）。\n当有 fd 就绪的时候，syscall.EpollWait 函数返回，并且将就绪的 fd 通过 events 传出，返回值 n 为就绪 fd 的个数。\n然后循环逐个遍历就绪的 fd，调用回调函数处理。\nfor i := 0; i n; i++ { if fd := int(events[i].Fd); fd != p.wfd { if err := iter(fd, nil); err != nil { return err } } else { } } evio 的事件处理 l.poll.Wait(func(fd int, note interface{}) error { if fd == 0 { return loopNote(s, l, note) } c := l.fdconns[fd] switch { case c == nil: return loopAccept(s, l, fd) case !c.opened: return loopOpened(s, l, c) case len(c.out)  0: return loopWrite(s, l, c) case c.action != None: return loopAction(s, l, c) default: return loopRead(s, l, c) } }) 当 epoll 检测到有就绪的 fd 时，会逐个调用上面的回调函数，evio 的主要逻辑也在这里。\n当 fd == 0 时，会执行 loopNote 函数。loopNote 主要是用来处理一些非 fd 就绪的事件，比如定时任务、强制退出等。当然，我们都知道 fd 为 0 是标准输入，所以此处并不是真的去处理 fd 为 0 的文件描述符（注册到 epoll 的文件描述 = 3）。作者知道 epoll 返回的就绪 fd 中不会有为 0 的情况，所以此处 fd 为 0，是作者调用时传入，用来表示一种特殊的唤醒场景。\nfunc (p *Poll) Wait(iter func(fd int, note interface{}) error) error { ... p.changes = p.changes[:0] if err := p.notes.ForEach(func(note interface{}) error { return iter(0, note) ... 我们跳到调用它的地方，可以看到只有在 p.notes.ForEach 这个函数中注册的回调函数中才会传入 fd 为 0 来执行 iter 回调函数。\nnotes noteQueue\nnoteQueue 的实现在 internal 目录中的 notequeue.go , 是一个无锁队列。我们不详细分析，只看下 ForEach 这个方法：\nfunc (q *noteQueue) ForEach(iter func(note interface{}) error) error { q.mu.Lock() if len(q.notes) == 0 { q.mu.Unlock() return nil } notes := q.notes q.notes = nil q.mu.Unlock() for _, note := range notes { if err := iter(note); err != nil { // 执行回调函数 \treturn err } } return nil } 当队列中有数据时， 会执行回调函数，即\nfunc(note interface{}) error { return iter(0, note) } 从上面的分析中可以我们已经知道为什么会有 fd 为 0 ，下面我们看下 loopNote 做什么。\nloopNote func loopNote(s *server, l *loop, note interface{}) error { var err error switch v := note.(type) { case time.Duration: delay, action := s.events.Tick() switch action { case None: case Shutdown: err = errClosing } s.tch  delay case error: // shutdown \terr = v case *conn: // Wake called for connection \tif l.fdconns[v.fd] != v { return nil // ignore stale wakes \t} return loopWake(s, l, v) } return err } 传入的 note 是 interface{} ，首先对 note 进行类型判断。\n当 note 是 time.Duration 时，调用回调函数 events.Tick() ，这是 evio 提供的定时任务接口。\n在 loopRun 函数中，如果设置了定时回调函数，会启动一个协程来来运行 loopTicker\nif l.idx == 0 \u0026\u0026 s.events.Tick != nil { go loopTicker(s, l) } loopTicker 实现如下，可以看出会定时去触发 l.poll.Trigger，并且传入 time.Duration(0)\nfunc loopTicker(s *server, l *loop) { for { if err := l.poll.Trigger(time.Duration(0)); err != nil { break } time.Sleep(s.tch) } } 我们跳到 poll.Trigger 的 linux 下的实现，可以发现 evio 在此处 p.notes.Add(note) ，也就是 time.Duration(0)\nfunc (p *Poll) Trigger(note interface{}) error { p.notes.Add(note) _, err := syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1}) return err } poll.Trigger 这个函数不仅仅是在 p.notes 里增加了一个 note，还唤醒了事件循环。\n当 epoll 中注册 fd 都没有就绪事件时，线程会挂起，epoll 的 wait 方法会处于阻塞状态。evio 使用 linux 提供的 eventfd 来实现事件循环的唤醒，也就是代码上中的 syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1}) ,往 p.wfd 这个文件描述符中写入了 8 个字节的数据。\np.wfd 是一个 eventfd , 是 Poll 结构体的成员，在 OpenPoll 时赋值，即打开一个 eventfd 代码如下：\ntype Poll struct { fd int // epoll fd \twfd int // wake fd \tnotes noteQueue } func OpenPoll() *Poll { l := new(Poll) p, err := syscall.EpollCreate1(0) if err != nil { panic(err) } l.fd = p r0, _, e0 := syscall.Syscall(syscall.SYS_EVENTFD2, 0, 0, 0) if e0 != 0 { syscall.Close(p) panic(err) } l.wfd = int(r0) l.AddRead(l.wfd) return l } syscall.Syscall(syscall.SYS_EVENTFD2, 0, 0, 0) 创建了一个 eventfd ，然后将这个 eventfd 注册到了 epoll 监听可读事件。当 syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1}) 时候，epoll 就会唤醒。\n但是，我翻了好久，也没有找到 evio 在哪里读取 eventfd 写入的8个字节（epoll）。这是一个 bug，所以在 linux 机器上，这是不能用的。\n 这个bug会造成 epoll 不断唤醒，cpu被长期占用\n 当我们注册了 evio 的定时任务 Tick 回调函数，程序启动后会往 eventfd 里写入 8 个字节数据，但是 evio 并没有读取，并且 evio 使用的是 epoll 的默认模式 LT，即只要可读缓冲区里还有数据，epoll 会一直不断唤醒，这是一个严重的 bug，作者应该没有在 linux 环境下严格测试过。\n我们抛开这个 bug， 继续来看 note 为 error 类型的情况。在 serve 函数中，当函数退出时，通过 l.poll.Trigger(errClosing) 来通知每个事件循环退出。\nfunc serve(events Events, listeners []*listener) error { ... defer func() { // wait on a signal for shutdown \ts.waitForShutdown() // notify all loops to close by closing all listeners \tfor _, l := range s.loops { l.poll.Trigger(errClosing) } // wait on all loops to complete reading events \ts.wg.Wait() // close loops and all outstanding connections \tfor _, l := range s.loops { for _, c := range l.fdconns { loopCloseConn(s, l, c, nil) } l.poll.Close() } //println(\"-- server stopped\") }() ... 当 note 为 *conn 这种情况，是用来提供给使用者主动唤醒当前事件循环\nfunc (c *conn) Wake() { if c.loop != nil { c.loop.poll.Trigger(c) } } loopAccept c := l.fdconns[fd] switch { case c == nil: return loopAccept(s, l, fd) type loop struct { idx int // loop index in the server loops list \tpoll *internal.Poll // epoll or kqueue \tpacket []byte // read packet buffer \tfdconns map[int]*conn // loop connections fd - conn \tcount int32 // connection count } fdconns 是用来存储已连接的TCP connection 信息，key 为 fd， value 为 *conn 。\n当 epoll 唤醒时，如果 fd 不在当前事件循环的连接，那就说明它是新连接，则执行 loopAccept 。\nfunc loopAccept(s *server, l *loop, fd int) error { for i, ln := range s.lns { if ln.fd == fd { if len(s.loops)  1 { switch s.balance { case LeastConnections: n := atomic.LoadInt32(\u0026l.count) for _, lp := range s.loops { if lp.idx != l.idx { if atomic.LoadInt32(\u0026lp.count) n { return nil // do not accept \t} } } case RoundRobin: idx := int(atomic.LoadUintptr(\u0026s.accepted)) % len(s.loops) if idx != l.idx { return nil // do not accept \t} atomic.AddUintptr(\u0026s.accepted, 1) } } if ln.pconn != nil { return loopUDPRead(s, l, i, fd) } nfd, sa, err := syscall.Accept(fd) if err != nil { if err == syscall.EAGAIN { return nil } return err } if err := syscall.SetNonblock(nfd, true); err != nil { return err } c := \u0026conn{fd: nfd, sa: sa, lnidx: i, loop: l} l.fdconns[c.fd] = c l.poll.AddReadWrite(c.fd) atomic.AddInt32(\u0026l.count, 1) break } } return nil } 因为 evio 支持多地址监听，所以会存在多个 listener ，也就是 s.lns 。\n第一步，先遍历所有的 listener 看看当前 epoll 中就绪的 fd 是哪一个 listener ，然后执行客户端的负载策略，决定新的客户端连接放在哪一个事件循环中。\n这里关于客户端的负载策略，evio 利用了 epoll 的惊群效果，所有的事件循环都会唤醒进入loopAccept，不符合负载策略直接 return nil。 关于这边的更多细节，可以看我的另一篇文章 【Golang 网络库 evio 一些问题/bug和思考】。\n接下来就是常规操作了， syscall.Accept(fd) 接受连接，然后  syscall.SetNonblock(nfd, true) 设置成非阻塞模式，\tl.poll.AddReadWrite(c.fd) 最后加入事件循环，注册可读可写事件。\nloopOpened func loopOpened(s *server, l *loop, c *conn) error { c.opened = true c.addrIndex = c.lnidx c.localAddr = s.lns[c.lnidx].lnaddr c.remoteAddr = internal.SockaddrToAddr(c.sa) if s.events.Opened != nil { out, opts, action := s.events.Opened(c) if len(out)  0 { c.out = append([]byte{}, out...) } c.action = action c.reuse = opts.ReuseInputBuffer if opts.TCPKeepAlive  0 { if _, ok := s.lns[c.lnidx].ln.(*net.TCPListener); ok { internal.SetKeepAlive(c.fd, int(opts.TCPKeepAlive/time.Second)) } } } if len(c.out) == 0 \u0026\u0026 c.action == None { l.poll.ModRead(c.fd) } return nil } loopOpened 是在 loopAccept 执行完成后，epoll 会立马再次唤醒然后执行的。\n因为在 loopAccept 中最后将新的客户端连接加入 epoll 管理时注册的是可读可写事件，当前的内核写缓冲区肯定是为空的，所以 epoll 会再次唤醒。\n... case !c.opened: return loopOpened(s, l, c) ... 唤醒后会执行到这个 case case !c.opened:，因为在 loopAccept 中并没有去设置这个值。\nloopOpened 内部的操作，主要就是设置一下 conn 的属性，然后调用客户注册的回调函数 events.Opened 。\n如果在回调函数中，没有给客户端发送数据，则需要重新注册，只注册可读事件，不然 epoll 会一直唤醒（可写事件）。\nloopAction func loopAction(s *server, l *loop, c *conn) error { switch c.action { default: c.action = None case Close: return loopCloseConn(s, l, c, nil) case Shutdown: return errClosing case Detach: return loopDetachConn(s, l, c, nil) } if len(c.out) == 0 \u0026\u0026 c.action == None { l.poll.ModRead(c.fd) } return nil } case c.action != None: return loopAction(s, l, c) loopAction 会在 case c.action != None: 的情况下执行， c.action 是执行完用户回调函数后会被赋值的状态。\n在会有 action 的 loopXXX 中都会有如下类似操作。\nif len(c.out) != 0 || c.action != None { l.poll.ModReadWrite(c.fd) } 也就是说 loopAction 依赖于 epoll 被可写事件再次唤醒来执行，这样会不会有问题呢？ 内核缓冲区满了？？\nloopAction 内部的主要操作就是根据 action 做一些处理，关闭连接等等。\nloopRead 和 loopWrite loopRead 和 loopWrite 主要就是调用系统调用读取和发送数据，并且调用用户回调函数，根据回调函数返回值来重新注册 epoll 的可读可写事件。\nfunc loopRead(s *server, l *loop, c *conn) error { var in []byte n, err := syscall.Read(c.fd, l.packet) if n == 0 || err != nil { if err == syscall.EAGAIN { return nil } return loopCloseConn(s, l, c, err) } in = l.packet[:n] if !c.reuse { in = append([]byte{}, in...) } if s.events.Data != nil { out, action := s.events.Data(c, in) c.action = action if len(out)  0 { c.out = append([]byte{}, out...) } } if len(c.out) != 0 || c.action != None { l.poll.ModReadWrite(c.fd) } return nil } 调用 n, err := syscall.Read(c.fd, l.packet) 读取内核缓冲区的数据，如果返回出错 err == syscall.EAGAIN 意思是再试一次，\u0008直接返回。\n如果 n == 0 或者 err 错误不为 syscall.EAGAIN ，则说明对方关闭了连接或是其他错误，直接 loopCloseConn 。\n然后调用用户回调函数 s.events.Data ，根据返回值做相应操作。c.action = action\n如果 out 里有数据，则赋给 c.out , 并且注册可读可写事件。\n如果 c.action != None ，同样需要注册可读可写事件，原因上面已经说过了。\nloopWrite 操作也大同小异，就不细说了。\n但是其实关于 loopWrite 和 loopRead 的处理是会有 bug 的，详情可以看另一篇文章。\n推荐库  gev 一个轻量、快速的基于 Reactor 模式的非阻塞 TCP 网络库。  ","wordCount":"2289","inLanguage":"en","datePublished":"2019-08-06T11:22:38+08:00","dateModified":"2019-08-06T11:22:38+08:00","author":{"@type":"Person","name":"徐旭"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mogutou.xyz/posts/open-source/evio-code/"},"publisher":{"@type":"Organization","name":"徐旭 的博客","logo":{"@type":"ImageObject","url":"https://mogutou.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://mogutou.xyz/ accesskey=h title="徐旭 的博客 (Alt + H)">徐旭 的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://mogutou.xyz/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://mogutou.xyz/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://mogutou.xyz/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://mogutou.xyz/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mogutou.xyz/>Home</a>&nbsp;»&nbsp;<a href=https://mogutou.xyz/posts/>Posts</a></div><h1 class=post-title>Golang 高性能网络库 evio 源码解析</h1><div class=post-meta>August 6, 2019&nbsp;·&nbsp;11 min&nbsp;·&nbsp;徐旭</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e5%8e%9f%e7%90%86 aria-label=原理>原理</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b aria-label=使用示例>使用示例</a></li><li><a href=#evio-%e7%9a%84%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af aria-label="evio 的事件循环">evio 的事件循环</a><ul><li><a href=#evioserve aria-label=evio.Serve>evio.Serve</a></li><li><a href=#looprun aria-label=loopRun>loopRun</a></li></ul></li><li><a href=#evio-%e7%9a%84%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86 aria-label="evio 的事件处理">evio 的事件处理</a><ul><li><a href=#loopnote aria-label=loopNote>loopNote</a></li><li><a href=#loopaccept aria-label=loopAccept>loopAccept</a></li><li><a href=#loopopened aria-label=loopOpened>loopOpened</a></li><li><a href=#loopaction aria-label=loopAction>loopAction</a></li><li><a href=#loopread-%e5%92%8c--loopwrite aria-label="loopRead 和  loopWrite">loopRead 和 loopWrite</a></li></ul></li><li><a href=#%e6%8e%a8%e8%8d%90%e5%ba%93 aria-label=推荐库>推荐库</a></li></ul></div></details></div><div class=post-content><blockquote><p>阅读前提：了解 epoll</p></blockquote><p><a href=https://github.com/tidwall/evio>evio</a> 是一个基于事件驱动的网络框架，它非常轻量而且相比 Go net 标准库更快。其底层使用epoll 和 kqueue 系统调度实现。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/Allenxuxu/blog/img/echo.png alt=echo.png></p><hr><h2 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h2><p>evio 是 Reactor 模式的简单实现。Reactor 本质就是“non-blocking IO + IO multiplexing”，通过非阻塞IO+ IO 多路复用来处理并发。程序运行一个或者多个事件循环，通过在事件循环中注册回调的方式实现业务逻辑。</p><p>evio 将所有文件描述符设为非阻塞，并注册到事件循环（ epoll / kqueue ）中。相较于传统的 per thread per connection 的处理方法，线程使用更少，线程资源利用率更高。</p><p>evio 需要在服务启动前，注册回调函数，当事件循环中有事件到来时，会调用回调函数处理。</p><h2 id=使用示例>使用示例<a hidden class=anchor aria-hidden=true href=#使用示例>#</a></h2><p>先从一个简单的 echo server 的例子来了解 evio 。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;flag&#34;</span>
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;log&#34;</span>
	<span style=color:#e6db74>&#34;strings&#34;</span>

	<span style=color:#e6db74>&#34;github.com/tidwall/evio&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>port</span> <span style=color:#66d9ef>int</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>loops</span> <span style=color:#66d9ef>int</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>udp</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>trace</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>reuseport</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stdlib</span> <span style=color:#66d9ef>bool</span>

	<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>IntVar</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>port</span>, <span style=color:#e6db74>&#34;port&#34;</span>, <span style=color:#ae81ff>5000</span>, <span style=color:#e6db74>&#34;server port&#34;</span>)
	<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>BoolVar</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>udp</span>, <span style=color:#e6db74>&#34;udp&#34;</span>, <span style=color:#66d9ef>false</span>, <span style=color:#e6db74>&#34;listen on udp&#34;</span>)
	<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>BoolVar</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>reuseport</span>, <span style=color:#e6db74>&#34;reuseport&#34;</span>, <span style=color:#66d9ef>false</span>, <span style=color:#e6db74>&#34;reuseport (SO_REUSEPORT)&#34;</span>)
	<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>BoolVar</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>trace</span>, <span style=color:#e6db74>&#34;trace&#34;</span>, <span style=color:#66d9ef>false</span>, <span style=color:#e6db74>&#34;print packets to console&#34;</span>)
	<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>IntVar</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>loops</span>, <span style=color:#e6db74>&#34;loops&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;num loops&#34;</span>)
	<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>BoolVar</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stdlib</span>, <span style=color:#e6db74>&#34;stdlib&#34;</span>, <span style=color:#66d9ef>false</span>, <span style=color:#e6db74>&#34;use stdlib&#34;</span>)
	<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>Parse</span>()

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>events</span> <span style=color:#a6e22e>evio</span>.<span style=color:#a6e22e>Events</span>
	<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>NumLoops</span> = <span style=color:#a6e22e>loops</span>
	<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Serving</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>srv</span> <span style=color:#a6e22e>evio</span>.<span style=color:#a6e22e>Server</span>) (<span style=color:#a6e22e>action</span> <span style=color:#a6e22e>evio</span>.<span style=color:#a6e22e>Action</span>) {
		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;echo server started on port %d (loops: %d)&#34;</span>, <span style=color:#a6e22e>port</span>, <span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>NumLoops</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>reuseport</span> {
			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;reuseport&#34;</span>)
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>stdlib</span> {
			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;stdlib&#34;</span>)
		}
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Data</span> = <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>evio</span>.<span style=color:#a6e22e>Conn</span>, <span style=color:#a6e22e>in</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#a6e22e>out</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>action</span> <span style=color:#a6e22e>evio</span>.<span style=color:#a6e22e>Action</span>) {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span> {
			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>TrimSpace</span>(string(<span style=color:#a6e22e>in</span>)))
		}
		<span style=color:#a6e22e>out</span> = <span style=color:#a6e22e>in</span>
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>scheme</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;tcp&#34;</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>udp</span> {
		<span style=color:#a6e22e>scheme</span> = <span style=color:#e6db74>&#34;udp&#34;</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>stdlib</span> {
		<span style=color:#a6e22e>scheme</span> <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;-net&#34;</span>
	}
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>evio</span>.<span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>events</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s://:%d?reuseport=%t&#34;</span>, <span style=color:#a6e22e>scheme</span>, <span style=color:#a6e22e>port</span>, <span style=color:#a6e22e>reuseport</span>)))
}
</code></pre></div><p>上面的例子主要就是注册了两个回调函数： events.Serving 和 events.Data 。</p><p>当 server 启动时，会来执行注册的 events.Serving 回调函数；
当有数据到来时，执行 events.Data 回调函数。</p><p>程序最后调用 evio.Serve 方法开启事件循环，程序在此处不断循环检测是否有事件发生并处理（有数据到来，有数据要发送&mldr;)。</p><p>evio 都是通过回调函数来执行业务逻辑的。 当客户端有数据发送过来时，调用用户注册的 events.Data 函数。</p><p>需要发送数据给客户端时，只可以通过注册的回调函数的返回值来返回，evio 框架来负责发送（有bug）。</p><p>回调函数的返回值主要有两个 <code>out []byte, action evio.Action</code> , out 就是需要发送给客户端的， Action 就是返回一些状态，用来关闭连接，或者服务器退出啥的操作。主要状态如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>const</span> (
	<span style=color:#75715e>// None indicates that no action should occur following an event.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>None</span> <span style=color:#a6e22e>Action</span> = <span style=color:#66d9ef>iota</span>
	<span style=color:#75715e>// Detach detaches a connection. Not available for UDP connections.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Detach</span>
	<span style=color:#75715e>// Close closes the connection.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Close</span>
	<span style=color:#75715e>// Shutdown shutdowns the server.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>Shutdown</span>
)
</code></pre></div><h2 id=evio-的事件循环>evio 的事件循环<a hidden class=anchor aria-hidden=true href=#evio-的事件循环>#</a></h2><h3 id=evioserve>evio.Serve<a hidden class=anchor aria-hidden=true href=#evioserve>#</a></h3><p>我们先来看下 evio.Serve 方法的实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>events</span> <span style=color:#a6e22e>Events</span>, <span style=color:#a6e22e>addr</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lns</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>listener</span>
	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
				<span style=color:#75715e>// 这个函数如果推出，需要关闭所有 listener
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ln</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>lns</span> {
			<span style=color:#a6e22e>ln</span>.close()
		}
	}()
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stdlib</span> <span style=color:#66d9ef>bool</span>
				<span style=color:#75715e>// 可以选择使用 stdlib（stdlib 主要是为了支持 非 *unix 平台）
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>addr</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>addr</span> {
	<span style=color:#75715e>// 生成 listener
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ln</span> <span style=color:#a6e22e>listener</span>
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>stdlibt</span> <span style=color:#66d9ef>bool</span>
		<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>network</span>, <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>opts</span>, <span style=color:#a6e22e>stdlibt</span> = <span style=color:#a6e22e>parseAddr</span>(<span style=color:#a6e22e>addr</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>stdlibt</span> {
			<span style=color:#a6e22e>stdlib</span> = <span style=color:#66d9ef>true</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>network</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;unix&#34;</span> {
			<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>RemoveAll</span>(<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>addr</span>)
		}
		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>network</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;udp&#34;</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>reusePort</span> {
				<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>pconn</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>reuseportListenPacket</span>(<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>network</span>, <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>addr</span>)
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>pconn</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>ListenPacket</span>(<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>network</span>, <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>addr</span>)
			}
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>reusePort</span> {
				<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>reuseportListen</span>(<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>network</span>, <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>addr</span>)
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>network</span>, <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>addr</span>)
			}
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>pconn</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>lnaddr</span> = <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>pconn</span>.<span style=color:#a6e22e>LocalAddr</span>()
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>lnaddr</span> = <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>Addr</span>()
		}
		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>stdlib</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>system</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
			}
		}
		<span style=color:#a6e22e>lns</span> = append(<span style=color:#a6e22e>lns</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ln</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>stdlib</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>stdserve</span>(<span style=color:#a6e22e>events</span>, <span style=color:#a6e22e>lns</span>)
		<span style=color:#75715e>// 使用 std net 库 启动server
</span><span style=color:#75715e></span>	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>serve</span>(<span style=color:#a6e22e>events</span>, <span style=color:#a6e22e>lns</span>)
				<span style=color:#75715e>// 使用 epoll or kqueue 启动server
</span><span style=color:#75715e></span>}
</code></pre></div><p>从 Serve 函数签名中可以看出 evio 是支持绑定多地址监听的</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span>  <span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>events</span> <span style=color:#a6e22e>Events</span>, <span style=color:#a6e22e>addr</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>string</span>)  <span style=color:#66d9ef>error</span>
</code></pre></div><p>使用方式如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>evio</span>.<span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>events</span>, <span style=color:#e6db74>&#34;tcp://localhost:5000&#34;</span>, <span style=color:#e6db74>&#34;tcp://192.168.0.10:5001&#34;</span>);
</code></pre></div><p>现在我们看看 evio 的核心部分: serve(events, lns)
，这里会启动 evio 的 sever 。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>serve</span>(<span style=color:#a6e22e>events</span> <span style=color:#a6e22e>Events</span>, <span style=color:#a6e22e>listeners</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>listener</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>numLoops</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>NumLoops</span>				<span style=color:#75715e>// 确定启动的事件循环数量
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>numLoops</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>numLoops</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>numLoops</span> = <span style=color:#ae81ff>1</span>
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>numLoops</span> = <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NumCPU</span>()
		}
	}

	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>server</span>{}
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span> = <span style=color:#a6e22e>events</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>lns</span> = <span style=color:#a6e22e>listeners</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>cond</span> = <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>NewCond</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>{})
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>balance</span> = <span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>LoadBalance</span>
	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tch</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>)

	<span style=color:#75715e>//println(&#34;-- server starting&#34;)
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Serving</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {					<span style=color:#75715e>// 如果注册了回调函数，就执行
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>svr</span> <span style=color:#a6e22e>Server</span>
		<span style=color:#a6e22e>svr</span>.<span style=color:#a6e22e>NumLoops</span> = <span style=color:#a6e22e>numLoops</span>
		<span style=color:#a6e22e>svr</span>.<span style=color:#a6e22e>Addrs</span> = make([]<span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Addr</span>, len(<span style=color:#a6e22e>listeners</span>))
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ln</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>listeners</span> {
			<span style=color:#a6e22e>svr</span>.<span style=color:#a6e22e>Addrs</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>lnaddr</span>
		}
		<span style=color:#a6e22e>action</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Serving</span>(<span style=color:#a6e22e>svr</span>)
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>action</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>None</span>:
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Shutdown</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
		}
	}

	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {									<span style=color:#75715e>// server 退出后的清理工作
</span><span style=color:#75715e></span>		<span style=color:#75715e>// wait on a signal for shutdown
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>waitForShutdown</span>()

		<span style=color:#75715e>// notify all loops to close by closing all listeners
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span> {
			<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>Trigger</span>(<span style=color:#a6e22e>errClosing</span>)
		}

		<span style=color:#75715e>// wait on all loops to complete reading events
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()

		<span style=color:#75715e>// close loops and all outstanding connections
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span> {
			<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>fdconns</span> {
				<span style=color:#a6e22e>loopCloseConn</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>nil</span>)
			}
			<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>Close</span>()
		}
		<span style=color:#75715e>//println(&#34;-- server stopped&#34;)
</span><span style=color:#75715e></span>	}()

	<span style=color:#75715e>// create loops locally and bind the listeners.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>numLoops</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>loop</span>{
			<span style=color:#a6e22e>idx</span>:     <span style=color:#a6e22e>i</span>,
			<span style=color:#a6e22e>poll</span>:    <span style=color:#a6e22e>internal</span>.<span style=color:#a6e22e>OpenPoll</span>(),
			<span style=color:#a6e22e>packet</span>:  make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>0xFFFF</span>), 	<span style=color:#75715e>// event loop 的 read 缓冲区
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>fdconns</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>conn</span>),
		}
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ln</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>listeners</span> {
			<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>AddRead</span>(<span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>fd</span>)			<span style=color:#75715e>// 将 fd 注册到 epoll 中并监听可读事件
</span><span style=color:#75715e></span>		}
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span> = append(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span>, <span style=color:#a6e22e>l</span>)
	}
	<span style=color:#75715e>// start loops in background
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(len(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span>))
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span> { 				<span style=color:#75715e>// 启动所有的 event loop
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>loopRun</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>serve 主要做这些事：</p><ol><li>根据配置启动指定数量的 event loop，如果传入配置的 loop 数量为 0 则设置启动一个事件循环，如果传入配置小于 0 则设置为运行平台的CPU核心数量</li><li>如果设置了回调函数 events.Serving ，运行它</li><li>按照指定 event loop 数量，创建 epoll 句柄生成 loop ，并将所有的 listener 注册到 epoll 监听可读事件（有客户端连接）</li><li>启动所有事件循环(一个事件循环一个 goroutine)</li></ol><p>需要注意的是，evio 将所有的 listener 的 fd 在每一个事件循环的 epoll 中都注册了。也就是说，如果有三个事件循环，一个 listener ，那么这个 listener 的 fd 会注册到三个 epoll 中。这就会出现 epoll 的惊群现象，感兴趣的可以自己搜索了解下。</p><p>evio 当一个新连接到来时，所有的事件循环都会唤醒，但是最终只有一个线程可以accept调用返回成功，其他线程（协程）的accept函数调用返回EAGAIN错误 。</p><h3 id=looprun>loopRun<a hidden class=anchor aria-hidden=true href=#looprun>#</a></h3><p>下面我们看看 loopRun 的内部实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loopRun</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>loop</span>) {
	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#75715e>//fmt.Println(&#34;-- loop stopped --&#34;, l.idx)
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>signalShutdown</span>()
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
	}()

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>idx</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Tick</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>loopTicker</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>)
	}

	<span style=color:#75715e>//fmt.Println(&#34;-- loop started --&#34;, l.idx)
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>Wait</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>fd</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fd</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopNote</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>note</span>)
		}
		<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>fdconns</span>[<span style=color:#a6e22e>fd</span>]
		<span style=color:#66d9ef>switch</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopAccept</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>fd</span>)
		<span style=color:#66d9ef>case</span> !<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>opened</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopOpened</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
		<span style=color:#66d9ef>case</span> len(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>out</span>) &gt; <span style=color:#ae81ff>0</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopWrite</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>None</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopAction</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
		<span style=color:#66d9ef>default</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopRead</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
		}
	})
}
</code></pre></div><p>l.poll.Wait 传入一个回调函数作为参数，当 epoll 收到事件通知时，会执行这个回调函数。</p><p>在这个函数中接受客户端连接，读取客户端数据，调用客户回调函数处理业务逻辑&mldr;</p><p>我们先来看下 poll.Wait 的内部实现，再看看 loopAccept，loopOpened，loopWrite 等函数。
loopRun 方法中最重要的就是 poll.Wait ，我们看看 Linux 下 epoll 的实现</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Poll</span>) <span style=color:#a6e22e>Wait</span>(<span style=color:#a6e22e>iter</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>fd</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>events</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>EpollEvent</span>, <span style=color:#ae81ff>64</span>)
	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>EpollWait</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>fd</span>, <span style=color:#a6e22e>events</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>EINTR</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>notes</span>.<span style=color:#a6e22e>ForEach</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>iter</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>note</span>)
		}); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fd</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>events</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Fd</span>); <span style=color:#a6e22e>fd</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>wfd</span> {
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>iter</span>(<span style=color:#a6e22e>fd</span>, <span style=color:#66d9ef>nil</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
				}
			} <span style=color:#66d9ef>else</span> {

			}
		}
	}
}
</code></pre></div><p>这个函数中是一个死循环，程序会阻塞在此处等待 epoll 的”通知“，然后处理就绪的 fd （读取/发送数据、执行用户注册的回调函数）。</p><p>当有 fd 就绪的时候，syscall.EpollWait 函数返回，并且将就绪的 fd 通过 events 传出，返回值 n 为就绪 fd 的个数。</p><p>然后循环逐个遍历就绪的 fd，调用回调函数处理。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fd</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>events</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Fd</span>); <span style=color:#a6e22e>fd</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>wfd</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>iter</span>(<span style=color:#a6e22e>fd</span>, <span style=color:#66d9ef>nil</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
	} <span style=color:#66d9ef>else</span> {

		}
}
</code></pre></div><h2 id=evio-的事件处理>evio 的事件处理<a hidden class=anchor aria-hidden=true href=#evio-的事件处理>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>Wait</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>fd</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fd</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopNote</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>note</span>)
		}
		<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>fdconns</span>[<span style=color:#a6e22e>fd</span>]
		<span style=color:#66d9ef>switch</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopAccept</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>fd</span>)
		<span style=color:#66d9ef>case</span> !<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>opened</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopOpened</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
		<span style=color:#66d9ef>case</span> len(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>out</span>) &gt; <span style=color:#ae81ff>0</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopWrite</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>None</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopAction</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
		<span style=color:#66d9ef>default</span>:
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopRead</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
		}
})
</code></pre></div><p>当 epoll 检测到有就绪的 fd 时，会逐个调用上面的回调函数，evio 的主要逻辑也在这里。</p><p>当 fd == 0 时，会执行 loopNote 函数。loopNote 主要是用来处理一些非 fd 就绪的事件，比如定时任务、强制退出等。当然，我们都知道 fd 为 0 是标准输入，所以此处并不是真的去处理 fd 为 0 的文件描述符（注册到 epoll 的文件描述 >= 3）。作者知道 epoll 返回的就绪 fd 中不会有为 0 的情况，所以此处 fd 为 0，是作者调用时传入，用来表示一种特殊的唤醒场景。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Poll</span>) <span style=color:#a6e22e>Wait</span>(<span style=color:#a6e22e>iter</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>fd</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>error</span> {
<span style=color:#f92672>...</span>
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>changes</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>changes</span>[:<span style=color:#ae81ff>0</span>]
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>notes</span>.<span style=color:#a6e22e>ForEach</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>iter</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>note</span>)
<span style=color:#f92672>...</span>
</code></pre></div><p>我们跳到调用它的地方，可以看到只有在 p.notes.ForEach 这个函数中注册的回调函数中才会传入 fd 为 0 来执行 iter 回调函数。</p><p><code>notes noteQueue</code></p><p>noteQueue 的实现在 internal 目录中的 notequeue.go , 是一个无锁队列。我们不详细分析，只看下 ForEach 这个方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>q</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>noteQueue</span>) <span style=color:#a6e22e>ForEach</span>(<span style=color:#a6e22e>iter</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>notes</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#a6e22e>notes</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>notes</span>
	<span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>notes</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>note</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>notes</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>iter</span>(<span style=color:#a6e22e>note</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {   <span style=color:#75715e>// 执行回调函数
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>当队列中有数据时， 会执行回调函数，即</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>iter</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>note</span>)
}
</code></pre></div><p>从上面的分析中可以我们已经知道为什么会有 fd 为 0 ，下面我们看下 loopNote 做什么。</p><h3 id=loopnote>loopNote<a hidden class=anchor aria-hidden=true href=#loopnote>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loopNote</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>loop</span>, <span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>note</span>.(<span style=color:#66d9ef>type</span>) {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>:
		<span style=color:#a6e22e>delay</span>, <span style=color:#a6e22e>action</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Tick</span>()
		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>action</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>None</span>:
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Shutdown</span>:
			<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>errClosing</span>
		}
		<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>delay</span>
	<span style=color:#66d9ef>case</span> <span style=color:#66d9ef>error</span>: <span style=color:#75715e>// shutdown
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>v</span>
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>conn</span>:
		<span style=color:#75715e>// Wake called for connection
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>fdconns</span>[<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>fd</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>v</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// ignore stale wakes
</span><span style=color:#75715e></span>		}
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopWake</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>v</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}
</code></pre></div><p>传入的 note 是 interface{} ，首先对 note 进行类型判断。</p><p>当 note 是 time.Duration 时，调用回调函数 events.Tick() ，这是 evio 提供的定时任务接口。</p><p>在 loopRun 函数中，如果设置了定时回调函数，会启动一个协程来来运行 loopTicker</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>idx</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Tick</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>loopTicker</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>)
}
</code></pre></div><p>loopTicker 实现如下，可以看出会定时去触发 l.poll.Trigger，并且传入 time.Duration(0)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loopTicker</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>loop</span>) {
	<span style=color:#66d9ef>for</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>Trigger</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#ae81ff>0</span>)); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>tch</span>)
	}
}
</code></pre></div><p>我们跳到 poll.Trigger 的 linux 下的实现，可以发现 evio 在此处 p.notes.Add(note) ，也就是 time.Duration(0)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Poll</span>) <span style=color:#a6e22e>Trigger</span>(<span style=color:#a6e22e>note</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>notes</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>note</span>)
	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>wfd</span>, []<span style=color:#66d9ef>byte</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>})
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}
</code></pre></div><p>poll.Trigger 这个函数不仅仅是在 p.notes 里增加了一个 note，还唤醒了事件循环。</p><p>当 epoll 中注册 fd 都没有就绪事件时，线程会挂起，epoll 的 wait 方法会处于阻塞状态。evio 使用
linux 提供的 eventfd 来实现事件循环的唤醒，也就是代码上中的 <code>syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1})</code> ,往 p.wfd 这个文件描述符中写入了 8 个字节的数据。</p><p>p.wfd 是一个 eventfd , 是 Poll 结构体的成员，在 OpenPoll 时赋值，即打开一个 eventfd 代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Poll</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>fd</span>    <span style=color:#66d9ef>int</span> <span style=color:#75715e>// epoll fd
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>wfd</span>   <span style=color:#66d9ef>int</span> <span style=color:#75715e>// wake fd
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>notes</span> <span style=color:#a6e22e>noteQueue</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>OpenPoll</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>Poll</span> {
	<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>Poll</span>)
	<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>EpollCreate1</span>(<span style=color:#ae81ff>0</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#a6e22e>err</span>)
	}
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>fd</span> = <span style=color:#a6e22e>p</span>
	<span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>e0</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>Syscall</span>(<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>SYS_EVENTFD2</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>Close</span>(<span style=color:#a6e22e>p</span>)
		panic(<span style=color:#a6e22e>err</span>)
	}
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>wfd</span> = int(<span style=color:#a6e22e>r0</span>)
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>AddRead</span>(<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>wfd</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>l</span>
}
</code></pre></div><p><code>syscall.Syscall(syscall.SYS_EVENTFD2, 0, 0, 0)</code> 创建了一个 eventfd ，然后将这个 eventfd 注册到了 epoll 监听可读事件。当 <code>syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1})</code> 时候，epoll 就会唤醒。</p><p>但是，我翻了好久，也没有找到 evio 在哪里读取 eventfd 写入的8个字节（epoll）。这是一个 bug，所以在 linux 机器上，这是不能用的。</p><blockquote><p>这个bug会造成 epoll 不断唤醒，cpu被长期占用</p></blockquote><p>当我们注册了 evio 的定时任务 Tick 回调函数，程序启动后会往 eventfd 里写入 8 个字节数据，但是 evio 并没有读取，并且 evio 使用的是 epoll 的默认模式 LT，即只要可读缓冲区里还有数据，epoll 会一直不断唤醒，这是一个严重的 bug，作者应该没有在 linux 环境下严格测试过。</p><p>我们抛开这个 bug， 继续来看 note 为 error 类型的情况。在 serve 函数中，当函数退出时，通过 <code>l.poll.Trigger(errClosing)</code> 来通知每个事件循环退出。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span>  <span style=color:#a6e22e>serve</span>(<span style=color:#a6e22e>events</span> <span style=color:#a6e22e>Events</span>, <span style=color:#a6e22e>listeners</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>listener</span>) <span style=color:#66d9ef>error</span> {
<span style=color:#f92672>...</span>

<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
	<span style=color:#75715e>// wait on a signal for shutdown
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>waitForShutdown</span>()

	<span style=color:#75715e>// notify all loops to close by closing all listeners
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span> {
		<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>Trigger</span>(<span style=color:#a6e22e>errClosing</span>)
	}

	<span style=color:#75715e>// wait on all loops to complete reading events
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()

	<span style=color:#75715e>// close loops and all outstanding connections
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span> {
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>fdconns</span> {
			<span style=color:#a6e22e>loopCloseConn</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>nil</span>)
		}
		<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>Close</span>()
	}
	<span style=color:#75715e>//println(&#34;-- server stopped&#34;)
</span><span style=color:#75715e></span>}()

<span style=color:#f92672>...</span>
</code></pre></div><p>当 note 为 *conn 这种情况，是用来提供给使用者主动唤醒当前事件循环</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>conn</span>) <span style=color:#a6e22e>Wake</span>() {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>loop</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>loop</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>Trigger</span>(<span style=color:#a6e22e>c</span>)
	}
}
</code></pre></div><h3 id=loopaccept>loopAccept<a hidden class=anchor aria-hidden=true href=#loopaccept>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>fdconns</span>[<span style=color:#a6e22e>fd</span>]
	<span style=color:#66d9ef>switch</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopAccept</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>fd</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>loop</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>idx</span>     <span style=color:#66d9ef>int</span>            <span style=color:#75715e>// loop index in the server loops list
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>poll</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>internal</span>.<span style=color:#a6e22e>Poll</span> <span style=color:#75715e>// epoll or kqueue
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>packet</span>  []<span style=color:#66d9ef>byte</span>         <span style=color:#75715e>// read packet buffer
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fdconns</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>conn</span>  <span style=color:#75715e>// loop connections fd -&gt; conn
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>count</span>   <span style=color:#66d9ef>int32</span>          <span style=color:#75715e>// connection count
</span><span style=color:#75715e></span>}
</code></pre></div><p>fdconns 是用来存储已连接的TCP connection 信息，key 为 fd， value 为 *conn 。</p><p>当 epoll 唤醒时，如果 fd 不在当前事件循环的连接，那就说明它是新连接，则执行 loopAccept 。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loopAccept</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>loop</span>, <span style=color:#a6e22e>fd</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ln</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>lns</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>fd</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>fd</span> {
			<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span>) &gt; <span style=color:#ae81ff>1</span> {
				<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>balance</span> {
				<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>LeastConnections</span>:
					<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>count</span>)
					<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>lp</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span> {
						<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lp</span>.<span style=color:#a6e22e>idx</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>idx</span> {
							<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>lp</span>.<span style=color:#a6e22e>count</span>) &lt; <span style=color:#a6e22e>n</span> {
								<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// do not accept
</span><span style=color:#75715e></span>							}
						}
					}
				<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>RoundRobin</span>:
					<span style=color:#a6e22e>idx</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadUintptr</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>accepted</span>)) <span style=color:#f92672>%</span> len(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>loops</span>)
					<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>idx</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>idx</span> {
						<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// do not accept
</span><span style=color:#75715e></span>					}
					<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddUintptr</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>accepted</span>, <span style=color:#ae81ff>1</span>)
				}
			}
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>pconn</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopUDPRead</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>fd</span>)
			}
			<span style=color:#a6e22e>nfd</span>, <span style=color:#a6e22e>sa</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>Accept</span>(<span style=color:#a6e22e>fd</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>EAGAIN</span> {
					<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
				}
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
			}
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>SetNonblock</span>(<span style=color:#a6e22e>nfd</span>, <span style=color:#66d9ef>true</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
			}
			<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>conn</span>{<span style=color:#a6e22e>fd</span>: <span style=color:#a6e22e>nfd</span>, <span style=color:#a6e22e>sa</span>: <span style=color:#a6e22e>sa</span>, <span style=color:#a6e22e>lnidx</span>: <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>loop</span>: <span style=color:#a6e22e>l</span>}
			<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>fdconns</span>[<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fd</span>] = <span style=color:#a6e22e>c</span>
			<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>AddReadWrite</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fd</span>)
			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>count</span>, <span style=color:#ae81ff>1</span>)
			<span style=color:#66d9ef>break</span>
		}
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>因为 evio 支持多地址监听，所以会存在多个 listener ，也就是 s.lns 。</p><p>第一步，先遍历所有的 listener 看看当前 epoll 中就绪的 fd 是哪一个 listener ，然后执行客户端的负载策略，决定新的客户端连接放在哪一个事件循环中。</p><p>这里关于客户端的负载策略，evio 利用了 epoll 的惊群效果，所有的事件循环都会唤醒进入loopAccept，不符合负载策略直接 return nil。 关于这边的更多细节，可以看我的另一篇文章 <a href=https://note.mogutou.xyz/articles/2019/08/15/1565876205121.html>【Golang 网络库 evio 一些问题/bug和思考】</a>。</p><p>接下来就是常规操作了，<code> syscall.Accept(fd)</code> 接受连接，然后 <code>syscall.SetNonblock(nfd, true)</code> 设置成非阻塞模式，<code> l.poll.AddReadWrite(c.fd)</code> 最后加入事件循环，注册可读可写事件。</p><h3 id=loopopened>loopOpened<a hidden class=anchor aria-hidden=true href=#loopopened>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loopOpened</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>loop</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>conn</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>opened</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>addrIndex</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lnidx</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>localAddr</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>lns</span>[<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lnidx</span>].<span style=color:#a6e22e>lnaddr</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>remoteAddr</span> = <span style=color:#a6e22e>internal</span>.<span style=color:#a6e22e>SockaddrToAddr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sa</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Opened</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>out</span>, <span style=color:#a6e22e>opts</span>, <span style=color:#a6e22e>action</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Opened</span>(<span style=color:#a6e22e>c</span>)
		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>out</span>) &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>out</span> = append([]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>out</span><span style=color:#f92672>...</span>)
		}
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> = <span style=color:#a6e22e>action</span>
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>reuse</span> = <span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>ReuseInputBuffer</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>TCPKeepAlive</span> &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>lns</span>[<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lnidx</span>].<span style=color:#a6e22e>ln</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>TCPListener</span>); <span style=color:#a6e22e>ok</span> {
				<span style=color:#a6e22e>internal</span>.<span style=color:#a6e22e>SetKeepAlive</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fd</span>, int(<span style=color:#a6e22e>opts</span>.<span style=color:#a6e22e>TCPKeepAlive</span><span style=color:#f92672>/</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>))
			}
		}
	}
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>out</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>None</span> {
		<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>ModRead</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fd</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>loopOpened 是在 loopAccept 执行完成后，epoll 会立马再次唤醒然后执行的。</p><p>因为在 loopAccept 中最后将新的客户端连接加入 epoll 管理时注册的是可读可写事件，当前的内核写缓冲区肯定是为空的，所以 epoll 会再次唤醒。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>...</span>
<span style=color:#66d9ef>case</span> !<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>opened</span>:
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopOpened</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
<span style=color:#f92672>...</span>
</code></pre></div><p>唤醒后会执行到这个 case <code>case !c.opened:</code>，因为在 loopAccept 中并没有去设置这个值。</p><p>loopOpened 内部的操作，主要就是设置一下 conn 的属性，然后调用客户注册的回调函数 <code>events.Opened</code> 。</p><p>如果在回调函数中，没有给客户端发送数据，则需要重新注册，只注册可读事件，不然 epoll 会一直唤醒（可写事件）。</p><h3 id=loopaction>loopAction<a hidden class=anchor aria-hidden=true href=#loopaction>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loopAction</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>loop</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>conn</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> {
	<span style=color:#66d9ef>default</span>:
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> = <span style=color:#a6e22e>None</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Close</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopCloseConn</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>nil</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Shutdown</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errClosing</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Detach</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopDetachConn</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>, <span style=color:#66d9ef>nil</span>)
	}
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>out</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>None</span> {
		<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>ModRead</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fd</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>None</span>:
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopAction</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>)
</code></pre></div><p>loopAction 会在 <code>case c.action != None:</code> 的情况下执行， c.action 是执行完用户回调函数后会被赋值的状态。</p><p>在会有 action 的 loopXXX 中都会有如下类似操作。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>out</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>None</span> {
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>ModReadWrite</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fd</span>)
}
</code></pre></div><p>也就是说 loopAction 依赖于 epoll 被可写事件再次唤醒来执行，这样会不会有问题呢？ 内核缓冲区满了？？</p><p>loopAction 内部的主要操作就是根据 action 做一些处理，关闭连接等等。</p><h3 id=loopread-和--loopwrite>loopRead 和 loopWrite<a hidden class=anchor aria-hidden=true href=#loopread-和--loopwrite>#</a></h3><p>loopRead 和 loopWrite 主要就是调用系统调用读取和发送数据，并且调用用户回调函数，根据回调函数返回值来重新注册 epoll 的可读可写事件。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loopRead</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>server</span>, <span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>loop</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>conn</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>in</span> []<span style=color:#66d9ef>byte</span>
	<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fd</span>, <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>packet</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>EAGAIN</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
		}
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>loopCloseConn</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>err</span>)
	}
	<span style=color:#a6e22e>in</span> = <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>packet</span>[:<span style=color:#a6e22e>n</span>]
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>reuse</span> {
		<span style=color:#a6e22e>in</span> = append([]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>in</span><span style=color:#f92672>...</span>)
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Data</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>out</span>, <span style=color:#a6e22e>action</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>Data</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>in</span>)
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> = <span style=color:#a6e22e>action</span>
		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>out</span>) &gt; <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>out</span> = append([]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>out</span><span style=color:#f92672>...</span>)
		}
	}
	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>out</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>action</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>None</span> {
		<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>poll</span>.<span style=color:#a6e22e>ModReadWrite</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fd</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>调用 <code>n, err := syscall.Read(c.fd, l.packet)</code> 读取内核缓冲区的数据，如果返回出错 <code>err == syscall.EAGAIN</code> 意思是再试一次，直接返回。</p><p>如果 n == 0 或者 err 错误不为 syscall.EAGAIN ，则说明对方关闭了连接或是其他错误，直接 loopCloseConn 。</p><p>然后调用用户回调函数 s.events.Data ，根据返回值做相应操作。<code>c.action = action</code></p><p>如果 out 里有数据，则赋给 c.out , 并且注册可读可写事件。</p><p>如果 <code>c.action != None</code> ，同样需要注册可读可写事件，原因上面已经说过了。</p><p>loopWrite 操作也大同小异，就不细说了。</p><p>但是其实关于 loopWrite 和 loopRead 的处理是会有 bug 的，详情可以看另一篇文章。</p><h2 id=推荐库>推荐库<a hidden class=anchor aria-hidden=true href=#推荐库>#</a></h2><ul><li><a href=https://github.com/Allenxuxu/gev>gev</a> 一个轻量、快速的基于 Reactor 模式的非阻塞 TCP 网络库。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://mogutou.xyz/tags/go/>Go</a></li><li><a href=https://mogutou.xyz/tags/open-source/>Open Source</a></li></ul><nav class=paginav><a class=prev href=https://mogutou.xyz/posts/open-source/evio-code-bug/><span class=title>« Prev Page</span><br><span>Golang 网络库 evio 一些问题/bug和思考</span></a>
<a class=next href=https://mogutou.xyz/posts/go/go-tutorials/><span class=title>Next Page »</span><br><span>Golang 极简入门教程</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Golang 高性能网络库 evio 源码解析 on twitter" href="https://twitter.com/intent/tweet/?text=Golang%20%e9%ab%98%e6%80%a7%e8%83%bd%e7%bd%91%e7%bb%9c%e5%ba%93%20evio%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&url=https%3a%2f%2fmogutou.xyz%2fposts%2fopen-source%2fevio-code%2f&hashtags=Go%2cOpenSource"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang 高性能网络库 evio 源码解析 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmogutou.xyz%2fposts%2fopen-source%2fevio-code%2f&title=Golang%20%e9%ab%98%e6%80%a7%e8%83%bd%e7%bd%91%e7%bb%9c%e5%ba%93%20evio%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&summary=Golang%20%e9%ab%98%e6%80%a7%e8%83%bd%e7%bd%91%e7%bb%9c%e5%ba%93%20evio%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&source=https%3a%2f%2fmogutou.xyz%2fposts%2fopen-source%2fevio-code%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang 高性能网络库 evio 源码解析 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmogutou.xyz%2fposts%2fopen-source%2fevio-code%2f&title=Golang%20%e9%ab%98%e6%80%a7%e8%83%bd%e7%bd%91%e7%bb%9c%e5%ba%93%20evio%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang 高性能网络库 evio 源码解析 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmogutou.xyz%2fposts%2fopen-source%2fevio-code%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang 高性能网络库 evio 源码解析 on whatsapp" href="https://api.whatsapp.com/send?text=Golang%20%e9%ab%98%e6%80%a7%e8%83%bd%e7%bd%91%e7%bb%9c%e5%ba%93%20evio%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%20-%20https%3a%2f%2fmogutou.xyz%2fposts%2fopen-source%2fevio-code%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang 高性能网络库 evio 源码解析 on telegram" href="https://telegram.me/share/url?text=Golang%20%e9%ab%98%e6%80%a7%e8%83%bd%e7%bd%91%e7%bb%9c%e5%ba%93%20evio%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&url=https%3a%2f%2fmogutou.xyz%2fposts%2fopen-source%2fevio-code%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=Allenxuxu/Allenxuxu.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2021 <a href=https://mogutou.xyz/>徐旭 的博客</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>