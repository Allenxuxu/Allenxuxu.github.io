<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 徐旭 的博客</title><meta name=keywords content><meta name=description content><meta name=author content="徐旭"><link rel=canonical href=https://allenxuxu.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.min.04512c372388e08b5118f5b117b2d3efef4ddae52017e16085c8d8d4e361c43d.css integrity="sha256-BFEsNyOI4ItRGPWxF7LT7+9N2uUgF+FghcjY1ONhxD0=" rel="preload stylesheet" as=style><link rel=icon href=https://allenxuxu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://allenxuxu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://allenxuxu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://allenxuxu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://allenxuxu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><link rel=alternate type=application/rss+xml href=https://allenxuxu.github.io/posts/index.xml><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://allenxuxu.github.io/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://allenxuxu.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://allenxuxu.github.io/ accesskey=h title="徐旭 的博客 (Alt + H)">徐旭 的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://allenxuxu.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://allenxuxu.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://allenxuxu.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://allenxuxu.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://allenxuxu.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>[gev] 自定义协议支持</h2></header><section class=entry-content><p>https://github.com/Allenxuxu/gev
gev 是一个轻量、快速的基于 Reactor 模式的非阻塞 TCP 网络库，支持自定义协议，轻松快速搭建高性能服务器。
TCP 为什么会"粘包" TCP 本身就是面向流的协议，就是一串没有界限的数据。所以本质上来说 TCP 粘包是一个伪命题。
TCP 底层并不关心上层业务数据，会套接字缓冲区的实际情况进行包的划分，一个完整的业务数据可能会被拆分成多次进行发送，也可能会将多个小的业务数据封装成一个大的数据包发送（Nagle算法）。
gev 如何优雅处理 gev 通过回调函数 OnMessage 通知用户数据到来，回调函数中会将用户数据缓冲区（ringbuffer）通过参数传递过来。
用户通过对 ringbuffer 操作，来进行数据解包，获取到完整用户数据后再进行业务操作。这样又一个明显的缺点，就是会让业务操作和自定义协议解析代码堆在一起。
所以，最近对 gev 进行了一次较大改动，主要是为了能够以插件的形式支持各种自定义的数据协议，让使用者可以便捷处理 TCP 粘包问题，专注于业务逻辑。
做法如下，定义一个接口 Protocol
// Protocol 自定义协议编解码接口 type Protocol interface { UnPacket(c *Connection, buffer *ringbuffer.RingBuffer) (interface{}, []byte) Packet(c *Connection, data []byte) []byte } 用户只需实现这个接口，并注册到 server 中，当客户端数据到来时，gev 会首先调用 UnPacket 方法，如果缓冲区中的数据足够组成一帧，则将数据解包，并返回真正的用户数据，然后在回调 OnMessage 函数并将数据通过参数传递。
下面，我们实现一个简单的自定义协议插件，来启动一个 Server ：
| 数据长度 n | payload | | 4字节 | n 字节 | // protocol....</p></section><footer class=entry-footer>October 31, 2019&nbsp;·&nbsp;3 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to [gev] 自定义协议支持" href=https://allenxuxu.github.io/posts/open-source/gev-protocol/></a></article><article class=post-entry><header class=entry-header><h2>Uber Go 风格指南</h2></header><section class=entry-content><p>Uber Go 风格指南 译文：https://github.com/Allenxuxu/uber-go-guide 原文：https://github.com/uber-go/guide/blob/master/style.md 简介 风格是指规范代码的共同约定。风格一词其实是有点用词不当的，因为共同约定的范畴远远不止 gofmt 所做的源代码格式化这些。
本指南旨在通过详尽描述 Uber 在编写 Go 代码中的注意事项（规定）来解释其中复杂之处。制定这些注意事项（规定）是为了提高代码可维护性同时也让工程师们高效的使用 Go 的特性。
这份指南最初由 Prashant Varanasi 和 Simon Newton 编写，目的是让一些同事快速上手 Go 。多年来，已经根据其他人的反馈不断修改。
这份文档记录了我们在 Uber 遵守的 Go 惯用准则。其中很多准则是 Go 的通用准则，其他方面依赖于外部资源：
Effective Go The Go common mistakes guide 所有的代码都应该通过 golint 和 go vet 检查。我们建议您设置编辑器：
保存时自动运行 goimports 自动运行 golint 和 go vet 来检查错误 您可以在这找到关于编辑器设定 Go tools 的相关信息：
https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins
指南 指向接口（interface）的指针 你基本永远不需要一个指向接口的指针。你应该直接将接口作为值传递，因为接口的底层数据就是指针。
一个接口包含两个字段：
类型指针，指向某些特定类型信息的指针。 数据指针。如果存储数据是一个指针变量，那就直接存储。如果存储数据是一个值变量，那就存储指向该值的指针。 如果你需要接口方法来修改这些底层数据，那你必须使用指针。...</p></section><footer class=entry-footer>October 13, 2019&nbsp;·&nbsp;13 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Uber Go 风格指南" href=https://allenxuxu.github.io/posts/go/uber-go-guide/></a></article><article class=post-entry><header class=entry-header><h2>Go 网络库并发吞吐量测试</h2></header><section class=entry-content><p>https://github.com/Allenxuxu/gev
本文主要测试 gev 网络库和其他三方 Go 网络库以及标准库的吞吐量对比。
测试对象 gev ：一个轻量、快速的基于 Reactor 模式的非阻塞 TCP 网络库 eviop ：evio 的优化版本 evio ：Fast event-loop networking for Go gnet ：eviop 的网络模型替换版本 net 标准库 测试方法 采用陈硕测试 muduo 使用的 ping pong 协议来测试吞吐量。
简单地说，ping pong 协议是客户端和服务器都实现 echo 协议。当 TCP 连接建立时，客户端向服务器发送一些数据，服务器会 echo 回这些数据，然后客户端再 echo 回服务器。这些数据就会像乒乓球一样在客户端和服务器之间来回传送，直到有一方断开连接为止。这是用来测试吞吐量的常用办法。
测试的客户端代码： https://github.com/Allenxuxu/gev/blob/master/benchmarks/client/main.go
测试脚本：https://github.com/Allenxuxu/gev/blob/master/benchmarks/bench-pingpong.sh
主要做两项测试：
单线程单个 work 协程测试，测试并发连接数为 10/100/1000/10000 时的吞吐量 4线程4个 work 协程测试，测试并发连接数为 10/100/1000/10000 时的吞吐量 所有测试中，ping pong 消息的大小均为 4096 bytes，客户端始终是4线程运行。...</p></section><footer class=entry-footer>September 22, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go 网络库并发吞吐量测试" href=https://allenxuxu.github.io/posts/open-source/gev-benchmark/></a></article><article class=post-entry><header class=entry-header><h2>开源 gev: Go 实现基于 Reactor 模式的非阻塞 TCP 网络库</h2></header><section class=entry-content><p>gev 轻量、快速的 Golang 网络库 gev 是一个轻量、快速的基于 Reactor 模式的非阻塞 TCP 网络库，支持自定义协议，轻松快速搭建高性能服务器。
为什么有 gev Golang 的 goroutine 虽然非常轻量，但是每启动一个 goroutine 仍需要 4k 左右的内存。读了鸟窝大佬的文章【百万 Go TCP 连接的思考: epoll方式减少资源占用】后，便去研究了了下 evio。
evio 虽然非常快，但是仍然存在一些问题，便尝试去优化它，于是有了 eviop 项目。关于 evio 的问题可以看我的另一篇博文 【Golang 网络库evio一些问题/bug和思考】。在优化 evio 完成 eviop 的过程中，因为其网络模型的缘故，愈加感觉修改它非常麻烦，成本比重新搞一个还高。
最终决定自己重搞一个，更加轻量，不需要的全去掉。加上大学时学习过 muduo ，便参考 muduo 的使用的 Reactor 模型实现 gev 。
在 linux 环境下，gev 底层使用 epoll ，这是 gev 会专注优化的地方。在 mac 下底层使用 kqueue，可能不会过多关注这部分的优化，毕竟很少有用 mac 做服务器的（Windows 环境"暂"不支持）。
特点 基于 epoll 和 kqueue 实现的高性能事件循环 支持多核多线程 动态扩容 Ring Buffer 实现的读写缓冲区 异步读写 SO_REUSEPORT 端口重用支持 支持 WebSocket 支持定时任务，延时任务 支持自定义协议，处理 TCP 粘包 网络模型 gev 只使用极少的 goroutine, 一个 goroutine 负责监听客户端连接，其他 goroutine （work 协程）负责处理已连接客户端的读写事件，work 协程数量可以配置，默认与运行主机 CPU 数量相同。...</p></section><footer class=entry-footer>September 19, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to 开源 gev: Go 实现基于 Reactor 模式的非阻塞 TCP 网络库" href=https://allenxuxu.github.io/posts/open-source/gev/></a></article><article class=post-entry><header class=entry-header><h2>Go net/http 浅析</h2></header><section class=entry-content><p>GO HTTP Server 使用标准库构建 HTTP 服务 Go 语言标准库自带一个完善的 net/http 包，可以很方便编写一个可以直接运行的 Web 服务。
package main import ( "log" "net/http" ) func hello(w http.ResponseWriter, r *http.Request) { log.Println(r.Method, r.Host, r.RequestURI) w.Write([]byte("hello")) } func main() { http.HandleFunc("/hello", hello) //设置访问的路由 // http.Handle("/hello", http.HandlerFunc(hello)) // 和上面写法等价 err := http.ListenAndServe(":9090", nil) //设置监听的端口并启动 HTTP 服务 if err != nil { log.Fatal("ListenAndServe: ", err) } } $ curl -v 127.0.0.1:9090/hello * Trying 127.0.0.1... * TCP_NODELAY set * Connected to 127....</p></section><footer class=entry-footer>September 15, 2019&nbsp;·&nbsp;6 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go net/http 浅析" href=https://allenxuxu.github.io/posts/go/go-http/></a></article><article class=post-entry><header class=entry-header><h2>Go channel 拷贝问题</h2></header><section class=entry-content><p>Go 的 channel 使用非常方便，但是总听说 channel 会拷贝传递的数据，生怕频繁拷贝影响效率。
究竟是怎么个拷贝法呢，下面会有两个 demo 验证下。
先说结论： Go channel 的发送接收数据的拷贝和 Go 的函数传参道理是一样的，都是默认的值拷贝。 如果你传递一个值，那么 Go 会复制一份新的；如果传递一个指针，则会拷贝这个指针，不会去拷贝这个指针所指的变量（这一点 C++ 选手可能会理解比较深）。
所以，如果你需要通过 channel 传递一个很大的 struct ，那么应该传递 指针。但是，要非常注意通过 channel 发送后，不要修改这个指，这会导致线程间潜在的竞争。
下面是两个验证的小 demo：
通过 channel 传递指针 package main import ( "fmt" "time" ) func recv(ch &lt;-chan *int) { time.Sleep(1 * time.Second) out := &lt;-ch fmt.Println("recv : ", out, *out) } func main() { i := 1 ch := make(chan *int, 2) fmt....</p></section><footer class=entry-footer>August 21, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go channel 拷贝问题" href=https://allenxuxu.github.io/posts/go/go-channel-copy/></a></article><article class=post-entry><header class=entry-header><h2>拥抱 Go module</h2></header><section class=entry-content><p>go get 拉包一直时国内选手头疼的问题，虽然梯子可以解决问题，但是总是有很慢的时候，而且需要每台电脑都配置，特别是 CI 的服务器等，很烦人。
七牛云开源了 goproxy ，还免费提供 https://goproxy.cn 作为代理来拉包。
不过 GOPROXY 只有在 Go module 下才能使用，索性全面拥抱 Go module 一劳永逸。
修改一下配置文件，即可：
sudo vi /etc/profile 在最后添加如下内容，开启 Go module 和代理：
export GO111MODULE=on export GOPROXY=https://goproxy.cn 让配置文件立即生效
source /etc/profile 接下来就可以畅快 Go 了！
PS： Go 1.16 已经默认开启 go moudle了。</p></section><footer class=entry-footer>August 20, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to 拥抱 Go module" href=https://allenxuxu.github.io/posts/go/go-module/></a></article><article class=post-entry><header class=entry-header><h2>Golang 网络库 evio 一些问题/bug和思考</h2></header><section class=entry-content><p>Fast event-loop networking for Go
最近翻了 evio 的源码，发现一些问题，主要集中在 linux 平台 epoll 上和读写的处理。
用来唤醒 epoll 的 eventfd 写入数据没有读出 listen 的 fd 注册到所有事件循环，epoll 的惊群问题 loopWrite 在内核缓冲区满，无法一次写入时，出现写入数据丢失 eventfd 的使用问题 在 internal/internal_linux.go 中封装了 epoll 的使用 API 。
// Poll ... type Poll struct { fd int // epoll fd wfd int // wake fd notes noteQueue } 在 OpenPoll 时，会创建一个 eventfd 并将 fd 赋值给 Poll 的 wfd 成员， 并且注册到 epoll 监听可读事件。...</p></section><footer class=entry-footer>August 15, 2019&nbsp;·&nbsp;3 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Golang 网络库 evio 一些问题/bug和思考" href=https://allenxuxu.github.io/posts/open-source/evio-code-bug/></a></article><article class=post-entry><header class=entry-header><h2>Golang 高性能网络库 evio 源码解析</h2></header><section class=entry-content><p>阅读前提：了解 epoll
evio 是一个基于事件驱动的网络框架，它非常轻量而且相比 Go net 标准库更快。其底层使用epoll 和 kqueue 系统调度实现。
原理 evio 是 Reactor 模式的简单实现。Reactor 本质就是“non-blocking IO + IO multiplexing”，通过非阻塞IO+ IO 多路复用来处理并发。程序运行一个或者多个事件循环，通过在事件循环中注册回调的方式实现业务逻辑。
evio 将所有文件描述符设为非阻塞，并注册到事件循环（ epoll / kqueue ）中。相较于传统的 per thread per connection 的处理方法，线程使用更少，线程资源利用率更高。
evio 需要在服务启动前，注册回调函数，当事件循环中有事件到来时，会调用回调函数处理。
使用示例 先从一个简单的 echo server 的例子来了解 evio 。
package main import ( "flag" "fmt" "log" "strings" "github.com/tidwall/evio" ) func main() { var port int var loops int var udp bool var trace bool var reuseport bool var stdlib bool flag....</p></section><footer class=entry-footer>August 6, 2019&nbsp;·&nbsp;11 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Golang 高性能网络库 evio 源码解析" href=https://allenxuxu.github.io/posts/open-source/evio-code/></a></article><article class=post-entry><header class=entry-header><h2>Golang 极简入门教程</h2></header><section class=entry-content><p>Hello World 我们以传统的“hello world”案例开始吧。
package main import "fmt" func main() { fmt.Println("Hello World") } Go的源文件以 .go 为后缀名，这些文件名均由小写字母（推荐做法）组成且不包含空格和其他特殊字符，如 main.go 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，如 main_test.go 。
Go是一门编译型语言,Go语言的工具链将源代码及其依赖转换成计算机的机器指令。Go语言提供的工具都通过一个单独的命令 go 调用，go 命令有一系列子命令。
$ go help Go is a tool for managing Go source code. Usage: go &lt;command> [arguments] The commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages ....</p></section><footer class=entry-footer>August 4, 2019&nbsp;·&nbsp;13 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Golang 极简入门教程" href=https://allenxuxu.github.io/posts/go/go-tutorials/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://allenxuxu.github.io/posts/>« Prev Page</a>
<a class=next href=https://allenxuxu.github.io/posts/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2021 <a href=https://allenxuxu.github.io/>徐旭 的博客</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>