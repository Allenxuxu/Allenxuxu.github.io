<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Uber Go 风格指南 | 徐旭 的博客</title><meta name=keywords content="Go"><meta name=description content="Uber Go 风格指南  译文：https://github.com/Allenxuxu/uber-go-guide 原文：https://github.com/uber-go/guide/blob/master/style.md  简介 风格是指规范代码的共同约定。风格一词其实是有点用词不当的，因为共同约定的范畴远远不止 gofmt 所做的源代码格式化这些。
本指南旨在通过详尽描述 Uber 在编写 Go 代码中的注意事项（规定）来解释其中复杂之处。制定这些注意事项（规定）是为了提高代码可维护性同时也让工程师们高效的使用 Go 的特性。
这份指南最初由 Prashant Varanasi 和 Simon Newton 编写，目的是让一些同事快速上手 Go 。多年来，已经根据其他人的反馈不断修改。
这份文档记录了我们在 Uber 遵守的 Go 惯用准则。其中很多准则是 Go 的通用准则，其他方面依赖于外部资源：
 Effective Go The Go common mistakes guide  所有的代码都应该通过 golint 和 go vet 检查。我们建议您设置编辑器：
 保存时自动运行 goimports 自动运行 golint 和 go vet 来检查错误  您可以在这找到关于编辑器设定 Go tools 的相关信息：
https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins
指南 指向接口（interface）的指针 你基本永远不需要一个指向接口的指针。你应该直接将接口作为值传递，因为接口的底层数据就是指针。
一个接口包含两个字段：
 类型指针，指向某些特定类型信息的指针。 数据指针。如果存储数据是一个指针变量，那就直接存储。如果存储数据是一个值变量，那就存储指向该值的指针。  如果你需要接口方法来修改这些底层数据，那你必须使用指针。"><meta name=author content="徐旭"><link rel=canonical href=https://mogutou.xyz/posts/go/uber-go-guide/><link crossorigin=anonymous href=/assets/css/stylesheet.min.04512c372388e08b5118f5b117b2d3efef4ddae52017e16085c8d8d4e361c43d.css integrity="sha256-BFEsNyOI4ItRGPWxF7LT7+9N2uUgF+FghcjY1ONhxD0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://mogutou.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mogutou.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mogutou.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://mogutou.xyz/apple-touch-icon.png><link rel=mask-icon href=https://mogutou.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><meta property="og:title" content="Uber Go 风格指南"><meta property="og:description" content="Uber Go 风格指南  译文：https://github.com/Allenxuxu/uber-go-guide 原文：https://github.com/uber-go/guide/blob/master/style.md  简介 风格是指规范代码的共同约定。风格一词其实是有点用词不当的，因为共同约定的范畴远远不止 gofmt 所做的源代码格式化这些。
本指南旨在通过详尽描述 Uber 在编写 Go 代码中的注意事项（规定）来解释其中复杂之处。制定这些注意事项（规定）是为了提高代码可维护性同时也让工程师们高效的使用 Go 的特性。
这份指南最初由 Prashant Varanasi 和 Simon Newton 编写，目的是让一些同事快速上手 Go 。多年来，已经根据其他人的反馈不断修改。
这份文档记录了我们在 Uber 遵守的 Go 惯用准则。其中很多准则是 Go 的通用准则，其他方面依赖于外部资源：
 Effective Go The Go common mistakes guide  所有的代码都应该通过 golint 和 go vet 检查。我们建议您设置编辑器：
 保存时自动运行 goimports 自动运行 golint 和 go vet 来检查错误  您可以在这找到关于编辑器设定 Go tools 的相关信息：
https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins
指南 指向接口（interface）的指针 你基本永远不需要一个指向接口的指针。你应该直接将接口作为值传递，因为接口的底层数据就是指针。
一个接口包含两个字段：
 类型指针，指向某些特定类型信息的指针。 数据指针。如果存储数据是一个指针变量，那就直接存储。如果存储数据是一个值变量，那就存储指向该值的指针。  如果你需要接口方法来修改这些底层数据，那你必须使用指针。"><meta property="og:type" content="article"><meta property="og:url" content="https://mogutou.xyz/posts/go/uber-go-guide/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-13T11:22:38+08:00"><meta property="article:modified_time" content="2019-10-13T11:22:38+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Uber Go 风格指南"><meta name=twitter:description content="Uber Go 风格指南  译文：https://github.com/Allenxuxu/uber-go-guide 原文：https://github.com/uber-go/guide/blob/master/style.md  简介 风格是指规范代码的共同约定。风格一词其实是有点用词不当的，因为共同约定的范畴远远不止 gofmt 所做的源代码格式化这些。
本指南旨在通过详尽描述 Uber 在编写 Go 代码中的注意事项（规定）来解释其中复杂之处。制定这些注意事项（规定）是为了提高代码可维护性同时也让工程师们高效的使用 Go 的特性。
这份指南最初由 Prashant Varanasi 和 Simon Newton 编写，目的是让一些同事快速上手 Go 。多年来，已经根据其他人的反馈不断修改。
这份文档记录了我们在 Uber 遵守的 Go 惯用准则。其中很多准则是 Go 的通用准则，其他方面依赖于外部资源：
 Effective Go The Go common mistakes guide  所有的代码都应该通过 golint 和 go vet 检查。我们建议您设置编辑器：
 保存时自动运行 goimports 自动运行 golint 和 go vet 来检查错误  您可以在这找到关于编辑器设定 Go tools 的相关信息：
https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins
指南 指向接口（interface）的指针 你基本永远不需要一个指向接口的指针。你应该直接将接口作为值传递，因为接口的底层数据就是指针。
一个接口包含两个字段：
 类型指针，指向某些特定类型信息的指针。 数据指针。如果存储数据是一个指针变量，那就直接存储。如果存储数据是一个值变量，那就存储指向该值的指针。  如果你需要接口方法来修改这些底层数据，那你必须使用指针。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mogutou.xyz/posts/"},{"@type":"ListItem","position":2,"name":"Uber Go 风格指南","item":"https://mogutou.xyz/posts/go/uber-go-guide/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Uber Go 风格指南","name":"Uber Go 风格指南","description":"Uber Go 风格指南  译文：https://github.com/Allenxuxu/uber-go-guide 原文：https://github.com/uber-go/guide/blob/master/style.md  简介 风格是指规范代码的共同约定。风格一词其实是有点用词不当的，因为共同约定的范畴远远不止 gofmt 所做的源代码格式化这些。\n本指南旨在通过详尽描述 Uber 在编写 Go 代码中的注意事项（规定）来解释其中复杂之处。制定这些注意事项（规定）是为了提高代码可维护性同时也让工程师们高效的使用 Go 的特性。\n这份指南最初由 Prashant Varanasi 和 Simon Newton 编写，目的是让一些同事快速上手 Go 。多年来，已经根据其他人的反馈不断修改。\n这份文档记录了我们在 Uber 遵守的 Go 惯用准则。其中很多准则是 Go 的通用准则，其他方面依赖于外部资源：\n Effective Go The Go common mistakes guide  所有的代码都应该通过 golint 和 go vet 检查。我们建议您设置编辑器：\n 保存时自动运行 goimports 自动运行 golint 和 go vet 来检查错误  您可以在这找到关于编辑器设定 Go tools 的相关信息：\nhttps://github.com/golang/go/wiki/IDEsAndTextEditorPlugins\n指南 指向接口（interface）的指针 你基本永远不需要一个指向接口的指针。你应该直接将接口作为值传递，因为接口的底层数据就是指针。\n一个接口包含两个字段：\n 类型指针，指向某些特定类型信息的指针。 数据指针。如果存储数据是一个指针变量，那就直接存储。如果存储数据是一个值变量，那就存储指向该值的指针。  如果你需要接口方法来修改这些底层数据，那你必须使用指针。","keywords":["Go"],"articleBody":"Uber Go 风格指南  译文：https://github.com/Allenxuxu/uber-go-guide 原文：https://github.com/uber-go/guide/blob/master/style.md  简介 风格是指规范代码的共同约定。风格一词其实是有点用词不当的，因为共同约定的范畴远远不止 gofmt 所做的源代码格式化这些。\n本指南旨在通过详尽描述 Uber 在编写 Go 代码中的注意事项（规定）来解释其中复杂之处。制定这些注意事项（规定）是为了提高代码可维护性同时也让工程师们高效的使用 Go 的特性。\n这份指南最初由 Prashant Varanasi 和 Simon Newton 编写，目的是让一些同事快速上手 Go 。多年来，已经根据其他人的反馈不断修改。\n这份文档记录了我们在 Uber 遵守的 Go 惯用准则。其中很多准则是 Go 的通用准则，其他方面依赖于外部资源：\n Effective Go The Go common mistakes guide  所有的代码都应该通过 golint 和 go vet 检查。我们建议您设置编辑器：\n 保存时自动运行 goimports 自动运行 golint 和 go vet 来检查错误  您可以在这找到关于编辑器设定 Go tools 的相关信息：\nhttps://github.com/golang/go/wiki/IDEsAndTextEditorPlugins\n指南 指向接口（interface）的指针 你基本永远不需要一个指向接口的指针。你应该直接将接口作为值传递，因为接口的底层数据就是指针。\n一个接口包含两个字段：\n 类型指针，指向某些特定类型信息的指针。 数据指针。如果存储数据是一个指针变量，那就直接存储。如果存储数据是一个值变量，那就存储指向该值的指针。  如果你需要接口方法来修改这些底层数据，那你必须使用指针。\n方法接收器和接口 具有值类型接收器的方法可以被值类型和指针类型调用。\n例如，\ntype S struct { data string } func (s S) Read() string { return s.data } func (s *S) Write(str string) { s.data = str } sVals := map[int]S{1: {\"A\"}} // 值类型变量只能调用 Read 方法 sVals[1].Read() // 无法编译通过: // sVals[0].Write(\"test\")  sPtrs := map[int]*S{1: {\"A\"}} // 指针类型变量可以调用 Read 和 Write 方法： sPtrs[1].Read() sPtrs[1].Write(\"test\") 同理，即使方法是值类型接收器，接口也可以通过指针来满足调用需求。\ntype F interface { f() } type S1 struct{} func (s S1) f() {} type S2 struct{} func (s *S2) f() {} s1Val := S1{} s1Ptr := \u0026S1{} s2Val := S2{} s2Ptr := \u0026S2{} var i F i = s1Val i = s1Ptr i = s2Ptr // 无法编译通过, 因为 s2Val 是一个值类型变量, 并且 f 方法不具有值类型接收器。 // i = s2Val Effective Go 中关于 Pointers vs. Values 写的很棒。\n零值Mutexes是有效的 零值的 sync.Mutex 和 sync.RWMutex 是有效的，所以基本是不需要一个指向 Mutex 的指针的。\nmu := new(sync.Mutex) mu.Lock() var mu sync.Mutex mu.Lock() 如果你希望通过指针操作结构体，mutex 可以作为其非指针结构体字段，或者最好直接嵌入结构体中。\ntype smap struct { sync.Mutex data map[string]string } func newSMap() *smap { return \u0026smap{ data: make(map[string]string), } } func (m *smap) Get(k string) string { m.Lock() defer m.Unlock() return m.data[k] } type SMap struct { mu sync.Mutex data map[string]string } func NewSMap() *SMap { return \u0026SMap{ data: make(map[string]string), } } func (m *SMap) Get(k string) string { m.mu.Lock() defer m.mu.Unlock() return m.data[k] } Slices和Maps的边界拷贝操作 切片和 map 包含一个指针来指向底层数据，所以当需要复制他们时需要特别注意。\n接收Slices和Maps 请记住，如果存储了对 slice 或 map 的引用，那么用户是可以对其进行修改。\nfunc (d *Driver) SetTrips(trips []Trip) { d.trips = trips } trips := ... d1.SetTrips(trips) // 是想修改 d1.trips 吗？ trips[0] = ... func (d *Driver) SetTrips(trips []Trip) { d.trips = make([]Trip, len(trips)) copy(d.trips, trips) } trips := ... d1.SetTrips(trips) // 修改 trips[0] 并且不影响 d1.trips 。 trips[0] = ... 返回 Slices 和 Maps 同理，谨慎提防用户修改暴露内部状态的 slices 和 maps 。\ntype Stats struct { sync.Mutex counters map[string]int } // Snapshot 返回当前状态 func (s *Stats) Snapshot() map[string]int { s.Lock() defer s.Unlock() return s.counters } // snapshot 不再受锁保护了！ snapshot := stats.Snapshot() type Stats struct { sync.Mutex counters map[string]int } func (s *Stats) Snapshot() map[string]int { s.Lock() defer s.Unlock() result := make(map[string]int, len(s.counters)) for k, v := range s.counters { result[k] = v } return result } // snapshot 是一分拷贝的内容了 snapshot := stats.Snapshot() 使用 defer 来做清理工作 使用 defer 来做资源的清理工作，例如文件的关闭和锁的释放。\np.Lock() if p.count 10 { p.Unlock() return p.count } p.count++ newCount := p.count p.Unlock() return newCount // 当有多处 return 时容易忘记释放锁 p.Lock() defer p.Unlock() if p.count 10 { return p.count } p.count++ return p.count // 可读性更高 defer 只有非常小的性能开销，只有当你能证明你的函数执行时间在纳秒级别时才可以不使用它。使用 defer 对代码可读性的提高是非常值得的，因为使用 defer 的成本真的非常小。特别是在一些主要是做内存操作的长函数中，函数中的其他计算操作远比 defer 重要。\nChannel 的大小设为 1 还是 None 通道的大小通常应该设为 1 或者设为无缓冲类型。默认情况下，通道是无缓冲类型的，大小为 0 。将通道大小设为其他任何数值都应该经过深思熟虑。认真考虑如何确定其大小，是什么阻止了工作中的通道被填满并阻塞了写入操作，以及何种情况会发生这样的现象。\n// 足以满足任何人！ c := make(chan int, 64) // 大小 为 1 c := make(chan int, 1) // or // 无缓冲 channel, 大小为 0 c := make(chan int) 枚举类型值从 1 开始 在 Go 中使用枚举的标准方法是声明一个自定义类型并通过 iota 关键字来声明一个 const 组。但是由于 Go 中变量的默认值都为该类型的零值，所以枚举变量的值应该从非零值开始。\ntype Operation int const ( Add Operation = iota Subtract Multiply ) // Add=0, Subtract=1, Multiply=2 type Operation int const ( Add Operation = iota + 1 Subtract Multiply ) // Add=1, Subtract=2, Multiply=3 在某些情况下，从零值开始也是可以的。例如，当零值是我们期望的默认行为时。\ntype LogOutput int const ( LogToStdout LogOutput = iota LogToFile LogToRemote ) // LogToStdout=0, LogToFile=1, LogToRemote=2 错误类型 有很多种方法来声明 errors:\n errors.New 声明简单的静态字符串错误信息 fmt.Errorf 声明格式化的字符串错误信息 为自定义类型实现 Error() 方法 通过 \"pkg/errors\".Wrap 包装错误类型  返回错误时，请考虑以下因素来作出最佳选择：\n 这是一个不需要其他额外信息的简单错误吗？如果是，使用error.New。 客户需要检测并处理此错误吗？如果是，那应该自定义类型，并实现 Error() 方法。 是否是在传递一个下游函数返回的错误？如果是，请查看error 封装部分。 其他，使用 fmt.Errorf 。  如果客户需要检测错误，并且是通过 errors.New 创建的一个简单的错误，请使用var 声明这个错误类型。\n// package foo  func Open() error { return errors.New(\"could not open\") } // package bar  func use() { if err := foo.Open(); err != nil { if err.Error() == \"could not open\" { // handle  } else { panic(\"unknown error\") } } } // package foo  var ErrCouldNotOpen = errors.New(\"could not open\") func Open() error { return ErrCouldNotOpen } // package bar  if err := foo.Open(); err != nil { if err == foo.ErrCouldNotOpen { // handle  } else { panic(\"unknown error\") } } 如果你有一个错误需要客户端来检测，并且你想向其添加更多信息（例如，它不是一个简单的静态字符串），那么应该声明一个自定义类型。\nfunc open(file string) error { return fmt.Errorf(\"file %q not found\", file) } func use() { if err := open(); err != nil { if strings.Contains(err.Error(), \"not found\") { // handle  } else { panic(\"unknown error\") } } } type errNotFound struct { file string } func (e errNotFound) Error() string { return fmt.Sprintf(\"file %q not found\", e.file) } func open(file string) error { return errNotFound{file: file} } func use() { if err := open(); err != nil { if _, ok := err.(errNotFound); ok { // handle  } else { panic(\"unknown error\") } } } 直接将自定义的错误类型设为导出需要特别小心，因为这意味着他们已经成为包的公开 API 的一部分了。更好的方式是暴露一个匹配函数来检测错误。\n// package foo  type errNotFound struct { file string } func (e errNotFound) Error() string { return fmt.Sprintf(\"file %q not found\", e.file) } func IsNotFoundError(err error) bool { _, ok := err.(errNotFound) return ok } func Open(file string) error { return errNotFound{file: file} } // package bar  if err := foo.Open(\"foo\"); err != nil { if foo.IsNotFoundError(err) { // handle  } else { panic(\"unknown error\") } } Error 封装 下面提供三种主要的方法来传递函数调用失败返回的错误：\n 如果想要维护原始错误类型并且不需要添加额外的上下文信息，就直接返回原始错误。 使用 \"pkg/errors\".Wrap 来增加上下文信息，这样返回的错误信息中就会包含更多的上下文信息，并且通过 \"pkg/errors\".Cause 可以提取出原始错误信息。 如果调用方不需要检测或处理特定的错误情况，就直接使用 fmt.Errorf 。  情况允许的话建议增加更多的上下文信息来代替诸如 \"connection refused\" 之类模糊的错误信息。返回 \"failed to call service foo: connection refused\" 用户可以知道更多有用的错误信息。\n在将上下文信息添加到返回的错误时，请避免使用 “failed to” 之类的短语以保持信息简洁，这些短语描述的状态是显而易见的，并且会随着错误在堆栈中的传递而逐渐堆积：\ns, err := store.New() if err != nil { return fmt.Errorf( \"failed to create new store: %s\", err) } s, err := store.New() if err != nil { return fmt.Errorf( \"new store: %s\", err) } failed to x: failed to y: failed to create new store: the error x: y: new store: the error 但是，如果这个错误信息是会被发送到另一个系统时，必须清楚的表明这是一个错误（例如，日志中 err 标签或者 Failed 前缀）。\n另见 Don’t just check errors, handle them gracefully。\n处理类型断言失败 类型断言的单返回值形式在遇到类型错误时会直接 panic 。因此，请始终使用 “comma ok” 惯用方法。\nt := i.(string) t, ok := i.(string) if !ok { // handle the error gracefully } 不要 Panic 生产级的代码必须避免 panics 。panics 是级联故障的主要源头。如果错误发生，函数应该返回错误并且允许调用者决定如果处理它。\nfunc foo(bar string) { if len(bar) == 0 { panic(\"bar must not be empty\") } // ... } func main() { if len(os.Args) != 2 { fmt.Println(\"USAGE: foo \") os.Exit(1) } foo(os.Args[1]) } func foo(bar string) error { if len(bar) == 0 return errors.New(\"bar must not be empty\") } // ...  return nil } func main() { if len(os.Args) != 2 { fmt.Println(\"USAGE: foo \") os.Exit(1) } if err := foo(os.Args[1]); err != nil { panic(err) } } Panic/recover 并不是错误处理策略。程序只有在遇到无法处理的情况下才可以 panic ，例如，nil 引用。程序初始化时是一个例外情况：程序启动时遇到需要终止执行的错误可能会 painc 。\nvar _statusTemplate = template.Must(template.New(\"name\").Parse(\"_statusHTML\")) 即使是在测试中，也应优先选择 t.Fatal 或 t.FailNow 而非 panic，以确保测试标记为失败。\n// func TestFoo(t *testing.T)  f, err := ioutil.TempFile(\"\", \"test\") if err != nil { panic(\"failed to set up test\") } // func TestFoo(t *testing.T)  f, err := ioutil.TempFile(\"\", \"test\") if err != nil { t.Fatal(\"failed to set up test\") } 使用 go.uber.org/atomic Go 的 sync/atomic 包仅仅提供针对原始类型（int32, int64, …）的原子操作。因此，很容易忘记使用原子操作来读写变量。\ngo.uber.org/atomic 通过隐藏基础类型，使这些操作类型安全。并且，它还提供一个方便的 atomic.Bool 类型。\ntype foo struct { running int32 // atomic } func (f* foo) start() { if atomic.SwapInt32(\u0026f.running, 1) == 1 { // already running…  return } // start the Foo } func (f *foo) isRunning() bool { return f.running == 1 // race! } type foo struct { running atomic.Bool } func (f *foo) start() { if f.running.Swap(true) { // already running…  return } // start the Foo } func (f *foo) isRunning() bool { return f.running.Load() } 性能 性能方面的特定准则，仅适用于热路径。\nstrconv 性能优于 fmt 将原语转换为字符串或从字符串转换时，strconv 速度比 fmt 更快。\nfor i := 0; i b.N; i++ { s := fmt.Sprint(rand.Int()) } for i := 0; i b.N; i++ { s := strconv.Itoa(rand.Int()) } BenchmarkFmtSprint-4 143 ns/op 2 allocs/op BenchmarkStrconv-4 64.2 ns/op 1 allocs/op 避免 string to byte 的转换 不要反复地从字符串字面量创建 byte 切片。相反，执行一次转换后存储结果供后续使用。\nfor i := 0; i b.N; i++ { w.Write([]byte(\"Hello world\")) } data := []byte(\"Hello world\") for i := 0; i b.N; i++ { w.Write(data) } BenchmarkBad-4 50000000 22.2 ns/op BenchmarkGood-4 500000000 3.25 ns/op 代码风格 声明分组 Go 支持将相似的声明分组：\nimport \"a\" import \"b\" import ( \"a\" \"b\" ) 分组同样适用于常量、变量和类型的声明：\nconst a = 1 const b = 2 var a = 1 var b = 2 type Area float64 type Volume float64 const ( a = 1 b = 2 ) var ( a = 1 b = 2 ) type ( Area float64 Volume float64 ) 仅将相似的声明放在同一组。不相关的声明不要放在同一个组内。\ntype Operation int const ( Add Operation = iota + 1 Subtract Multiply ENV_VAR = \"MY_ENV\" ) type Operation int const ( Add Operation = iota + 1 Subtract Multiply ) const ENV_VAR = \"MY_ENV\" 声明分组可以在任意位置使用。例如，可以在函数内部使用。\nfunc f() string { var red = color.New(0xff0000) var green = color.New(0x00ff00) var blue = color.New(0x0000ff) ... } func f() string { var ( red = color.New(0xff0000) green = color.New(0x00ff00) blue = color.New(0x0000ff) ) ... } Import 组内顺序 import 有两类导入组：\n 标准库 其他  goimports 默认的分组如下：\nimport ( \"fmt\" \"os\" \"go.uber.org/atomic\" \"golang.org/x/sync/errgroup\" ) import ( \"fmt\" \"os\" \"go.uber.org/atomic\" \"golang.org/x/sync/errgroup\" ) 包名 当为包命名时，请注意如下事项：\n 字符全部小写，没有大写或者下划线 在大多数情况下引入包不需要去重命名 简单明了，命名需要能够在被导入的地方准确识别 不要使用复数。例如，net/url, 而不是 net/urls 不要使用“common”，“util”，“shared”或“lib”之类的。这些都是不好的，表达信息不明的名称  另见 Package Names 和 Style guideline for Go packages\n函数命名 我们遵循 Go 社区关于使用的 MixedCaps for function names。有一种情况例外，对相关的测试用例进行分组时，函数名可能包含下划线，如: TestMyFunction_WhatIsBeingTested。\n包导入别名 如果包的名称与导入路径的最后一个元素不匹配，那必须使用导入别名。\nimport ( \"net/http\" client \"example.com/client-go\" trace \"example.com/trace/v2\" ) 在其他情况下，除非导入的包名之间有直接冲突，否则应避免使用导入别名。\nimport ( \"fmt\" \"os\" nettrace \"golang.net/x/trace\" ) import ( \"fmt\" \"os\" \"runtime/trace\" nettrace \"golang.net/x/trace\" ) 函数分组与排布顺序  函数应该粗略的按照调用顺序来排布 同一文件中的函数应该按照接收器的类型来分组排布  所以，公开的函数应排布在文件首，并在 struct、const 和 var 定义之后。\nnewXYZ()/ NewXYZ() 之类的函数应该排布在声明类型之后，具有接收器的其余方法之前。\n因为函数是按接收器类别分组的，所以普通工具函数应排布在文件末尾。\nfunc (s *something) Cost() { return calcCost(s.weights) } type something struct{ ... } func calcCost(n int[]) int {...} func (s *something) Stop() {...} func newSomething() *something { return \u0026something{} } type something struct{ ... } func newSomething() *something { return \u0026something{} } func (s *something) Cost() { return calcCost(s.weights) } func (s *something) Stop() {...} func calcCost(n int[]) int {...} 减少嵌套 代码应该通过尽可能地先处理错误情况/特殊情况，并且及早返回或继续下一循环来减少嵌套。尽量减少嵌套于多个级别的代码数量。\nfor _, v := range data { if v.F1 == 1 { v = process(v) if err := v.Call(); err == nil { v.Send() } else { return err } } else { log.Printf(\"Invalid v: %v\", v) } } for _, v := range data { if v.F1 != 1 { log.Printf(\"Invalid v: %v\", v) continue } v = process(v) if err := v.Call(); err != nil { return err } v.Send() } 不必要的 else 如果一个变量在 if 的两个分支中都设置了，那应该使用单个 if 。\nvar a int if b { a = 100 } else { a = 10 } a := 10 if b { a = 100 } 全局变量声明 在顶层使用标准 var 关键字声明变量时，不要显式指定类型，除非它与表达式的返回类型不同。\nvar _s string = F() func F() string { return \"A\" } var _s = F() // F 已经明确声明返回一个字符串类型，我们没有必要显式指定 _s 的类型  func F() string { return \"A\" } 如果表达式的返回类型与所需的类型不完全匹配，请显示指定类型。\ntype myError struct{} func (myError) Error() string { return \"error\" } func F() myError { return myError{} } var _e error = F() // F 返回一个 myError 类型的实例，但是我们要 error 类型 非导出的全局变量或者常量以 _ 开头 非导出的全局变量和常量前面加上前缀 _，以明确表示它们是全局符号。\n例外：未导出的错误类型变量，应以 err 开头。\n解释：顶级（全局）变量和常量具有包范围作用域。使用通用名称命名，可能在其他文件中不经意间地使用一个错误值。\n// foo.go  const ( defaultPort = 8080 defaultUser = \"user\" ) // bar.go  func Bar() { defaultPort := 9090 ... fmt.Println(\"Default port\", defaultPort) // We will not see a compile error if the first line of  // Bar() is deleted. } // foo.go  const ( _defaultPort = 8080 _defaultUser = \"user\" ) 结构体中的嵌入类型 嵌入式类型（例如 mutex ）应该放置在结构体字段列表的顶部，并且必须以空行与常规字段隔开。\ntype Client struct { version int http.Client } type Client struct { http.Client version int } 使用字段名来初始化结构 初始化结构体时，必须指定字段名称。go vet 强制执行。\nk := User{\"John\", \"Doe\", true} k := User{ FirstName: \"John\", LastName: \"Doe\", Admin: true, } 例外：在测试文件中，如果结构体只有3个或更少的字段，则可以省略字段名称。\ntests := []struct{ }{ op Operation want string }{ {Add, \"add\"}, {Subtract, \"subtract\"}, } 局部变量声明 如果声明局部变量时需要明确设值，应使用短变量声明形式（:=）。\nvar s = \"foo\" s := \"foo\" 但是，在某些情况下，使用 var 关键字声明变量，默认的初始化值会更清晰。例如，声明空切片。\nfunc f(list []int) { filtered := []int{} for _, v := range list { if v  10 { filtered = append(filtered, v) } } } func f(list []int) { var filtered []int for _, v := range list { if v  10 { filtered = append(filtered, v) } } } nil是一个有效的slice nil 是一个有效的长度为 0 的 slice，这意味着：\n  不应明确返回长度为零的切片，而应该直接返回 nil 。\nif x == \"\" { return []int{} } if x == \"\" { return nil }   若要检查切片是否为空，始终使用 len(s) == 0 ，不要与 nil 比较来检查。\nfunc isEmpty(s []string) bool { return s == nil } func isEmpty(s []string) bool { return len(s) == 0 }   零值切片（通过 var 声明的切片）可直接使用，无需调用 make 创建。\nnums := []int{} // or, nums := make([]int)  if add1 { nums = append(nums, 1) } if add2 { nums = append(nums, 2) } var nums []int if add1 { nums = append(nums, 1) } if add2 { nums = append(nums, 2) }   缩小变量作用域 如果有可能，尽量缩小变量作用范围，除非这样与减少嵌套的规则冲突。\nerr := ioutil.WriteFile(name, data, 0644) if err != nil { return err } if err := ioutil.WriteFile(name, data, 0644); err != nil { return err } 如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。\nif data, err := ioutil.ReadFile(name); err == nil { err = cfg.Decode(data) if err != nil { return err } fmt.Println(cfg) return nil } else { return err } data, err := ioutil.ReadFile(name) if err != nil { return err } if err := cfg.Decode(data); err != nil { return err } fmt.Println(cfg) return nil 避免裸参数 函数调用中的裸参数可能会降低代码可读性。所以当参数名称的含义不明显时，请为参数添加 C 样式的注释（/* … */）。\n// func printInfo(name string, isLocal, done bool)  printInfo(\"foo\", true, true) // func printInfo(name string, isLocal, done bool)  printInfo(\"foo\", true /* isLocal */, true /* done */) 上面更好的作法是将 bool 类型替换为自定义类型，从而使代码更易读且类型安全。将来需要拓展时，该参数也可以不止两个状态（true/false）。\ntype Region int const ( UnknownRegion Region = iota Local ) type Status int const ( StatusReady = iota + 1 StatusDone // 也许将来我们会有 StatusInProgress。 ) func printInfo(name string, region Region, status Status) 使用原始字符串字面值，避免使用转义 Go 支持原始字符串字面值，可以多行并包含引号。使用它可以避免使用肉眼阅读较为困难的手工转义的字符串。\nwantError := \"unknown name:\\\"test\\\"\" wantError := `unknown error:\"test\"` 初始化结构体引用 在初始化结构引用时，使用 \u0026T{} 而非 new(T)，以使其与结构体初始化方式保持一致。\nsval := T{Name: \"foo\"} // 定义方式不一致 sptr := new(T) sptr.Name = \"bar\" sval := T{Name: \"foo\"} sptr := \u0026T{Name: \"bar\"} 格式化字符串放在 Printf 外部 如果为 Printf-style 函数声明格式化字符串，将格式化字符串放在函数外面 ，并将其设置为 const 常量。\n这有助于 go vet 对格式字符串进行静态分析。\nmsg := \"unexpected values %v, %v\\n\" fmt.Printf(msg, 1, 2) const msg = \"unexpected values %v, %v\\n\" fmt.Printf(msg, 1, 2) 为 Printf 样式函数命名 声明 Printf-style 函数时，请确保 go vet 可以检查它的格式化字符串。\n这意味着应尽可能使用预定义的 Printf-style 函数名称。go vet 默认会检查它们。更多相关信息，请参见 Printf系列。\n如果不能使用预定义的名称，请以 f 结尾：Wrapf，而非 Wrap。因为 go vet 可以指定检查特定的 Printf 样式名称，但名称必须以 f 结尾。\n$ go vet -printfuncs=wrapf,statusf ... 另见 go vet: Printf family check\n模式 测试表 在核心测试逻辑重复时，将表驱动测试与子测试一起使用，以避免重复代码。\n// func TestSplitHostPort(t *testing.T)  host, port, err := net.SplitHostPort(\"192.0.2.0:8000\") require.NoError(t, err) assert.Equal(t, \"192.0.2.0\", host) assert.Equal(t, \"8000\", port) host, port, err = net.SplitHostPort(\"192.0.2.0:http\") require.NoError(t, err) assert.Equal(t, \"192.0.2.0\", host) assert.Equal(t, \"http\", port) host, port, err = net.SplitHostPort(\":8000\") require.NoError(t, err) assert.Equal(t, \"\", host) assert.Equal(t, \"8000\", port) host, port, err = net.SplitHostPort(\"1:8\") require.NoError(t, err) assert.Equal(t, \"1\", host) assert.Equal(t, \"8\", port) // func TestSplitHostPort(t *testing.T)  tests := []struct{ give string wantHost string wantPort string }{ { give: \"192.0.2.0:8000\", wantHost: \"192.0.2.0\", wantPort: \"8000\", }, { give: \"192.0.2.0:http\", wantHost: \"192.0.2.0\", wantPort: \"http\", }, { give: \":8000\", wantHost: \"\", wantPort: \"8000\", }, { give: \"1:8\", wantHost: \"1\", wantPort: \"8\", }, } for _, tt := range tests { t.Run(tt.give, func(t *testing.T) { host, port, err := net.SplitHostPort(tt.give) require.NoError(t, err) assert.Equal(t, tt.wantHost, host) assert.Equal(t, tt.wantPort, port) }) } 测试表使得向错误消息注入上下文信息，减少重复的逻辑，添加新的测试用例变得更加容易。\n我们遵循这样的约定：将结构体切片称为 tests。 每个测试用例称为 tt 。此外，我们鼓励使用 give 和 want 前缀说明每个测试用例的输入和输出值。\ntests := []struct{ give string wantHost string wantPort string }{ // ... } for _, tt := range tests { // ... } 功能选项 功能选项是一种模式，声明一个不透明 Option 类型，该类型记录某些内部结构体的信息。您的函数接受这些不定数量的选项参数，并将选项参数上的信息作用于内部结构上。\n此模式可用于扩展构造函数和实现其他公共 API 中的可选参数，特别是这些参数已经有三个或者超过三个的情况下。\n// package db  func Connect( addr string, timeout time.Duration, caching bool, ) (*Connection, error) { // ... } // Timeout and caching must always be provided, // even if the user wants to use the default.  db.Connect(addr, db.DefaultTimeout, db.DefaultCaching) db.Connect(addr, newTimeout, db.DefaultCaching) db.Connect(addr, db.DefaultTimeout, false /* caching */) db.Connect(addr, newTimeout, false /* caching */) type options struct { timeout time.Duration caching bool } // Option overrides behavior of Connect. type Option interface { apply(*options) } type optionFunc func(*options) func (f optionFunc) apply(o *options) { f(o) } func WithTimeout(t time.Duration) Option { return optionFunc(func(o *options) { o.timeout = t }) } func WithCaching(cache bool) Option { return optionFunc(func(o *options) { o.caching = cache }) } // Connect creates a connection. func Connect( addr string, opts ...Option, ) (*Connection, error) { options := options{ timeout: defaultTimeout, caching: defaultCaching, } for _, o := range opts { o.apply(\u0026options) } // ... } // Options must be provided only if needed.  db.Connect(addr) db.Connect(addr, db.WithTimeout(newTimeout)) db.Connect(addr, db.WithCaching(false)) db.Connect( addr, db.WithCaching(false), db.WithTimeout(newTimeout), ) 另见，\n Self-referential functions and the design of options Functional options for friendly APIs  ","wordCount":"2608","inLanguage":"en","datePublished":"2019-10-13T11:22:38+08:00","dateModified":"2019-10-13T11:22:38+08:00","author":{"@type":"Person","name":"徐旭"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mogutou.xyz/posts/go/uber-go-guide/"},"publisher":{"@type":"Organization","name":"徐旭 的博客","logo":{"@type":"ImageObject","url":"https://mogutou.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://mogutou.xyz/ accesskey=h title="徐旭 的博客 (Alt + H)">徐旭 的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://mogutou.xyz/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://mogutou.xyz/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://mogutou.xyz/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://mogutou.xyz/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mogutou.xyz/>Home</a>&nbsp;»&nbsp;<a href=https://mogutou.xyz/posts/>Posts</a></div><h1 class=post-title>Uber Go 风格指南</h1><div class=post-meta>October 13, 2019&nbsp;·&nbsp;13 min&nbsp;·&nbsp;徐旭</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#uber-go-%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97 aria-label="Uber Go 风格指南">Uber Go 风格指南</a><ul><li><a href=#%e7%ae%80%e4%bb%8b aria-label=简介>简介</a></li><li><a href=#%e6%8c%87%e5%8d%97 aria-label=指南>指南</a><ul><li><a href=#%e6%8c%87%e5%90%91%e6%8e%a5%e5%8f%a3interface%e7%9a%84%e6%8c%87%e9%92%88 aria-label=指向接口（interface）的指针>指向接口（interface）的指针</a></li><li><a href=#%e6%96%b9%e6%b3%95%e6%8e%a5%e6%94%b6%e5%99%a8%e5%92%8c%e6%8e%a5%e5%8f%a3 aria-label=方法接收器和接口>方法接收器和接口</a></li><li><a href=#%e9%9b%b6%e5%80%bcmutexes%e6%98%af%e6%9c%89%e6%95%88%e7%9a%84 aria-label=零值Mutexes是有效的>零值Mutexes是有效的</a></li><li><a href=#slices%e5%92%8cmaps%e7%9a%84%e8%be%b9%e7%95%8c%e6%8b%b7%e8%b4%9d%e6%93%8d%e4%bd%9c aria-label=Slices和Maps的边界拷贝操作>Slices和Maps的边界拷贝操作</a><ul><li><a href=#%e6%8e%a5%e6%94%b6slices%e5%92%8cmaps aria-label=接收Slices和Maps>接收Slices和Maps</a></li><li><a href=#%e8%bf%94%e5%9b%9e-slices-%e5%92%8c-maps aria-label="返回 Slices 和 Maps">返回 Slices 和 Maps</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8-defer-%e6%9d%a5%e5%81%9a%e6%b8%85%e7%90%86%e5%b7%a5%e4%bd%9c aria-label="使用 defer 来做清理工作">使用 defer 来做清理工作</a></li><li><a href=#channel-%e7%9a%84%e5%a4%a7%e5%b0%8f%e8%ae%be%e4%b8%ba-1-%e8%bf%98%e6%98%af-none aria-label="Channel 的大小设为 1 还是 None">Channel 的大小设为 1 还是 None</a></li><li><a href=#%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b%e5%80%bc%e4%bb%8e-1-%e5%bc%80%e5%a7%8b aria-label="枚举类型值从 1 开始">枚举类型值从 1 开始</a></li><li><a href=#%e9%94%99%e8%af%af%e7%b1%bb%e5%9e%8b aria-label=错误类型>错误类型</a></li><li><a href=#error-%e5%b0%81%e8%a3%85 aria-label="Error 封装">Error 封装</a></li><li><a href=#%e5%a4%84%e7%90%86%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80%e5%a4%b1%e8%b4%a5 aria-label=处理类型断言失败>处理类型断言失败</a></li><li><a href=#%e4%b8%8d%e8%a6%81-panic aria-label="不要 Panic">不要 Panic</a></li><li><a href=#%e4%bd%bf%e7%94%a8-gouberorgatomic aria-label="使用 go.uber.org/atomic">使用 go.uber.org/atomic</a></li></ul></li><li><a href=#%e6%80%a7%e8%83%bd aria-label=性能>性能</a><ul><li><a href=#strconv-%e6%80%a7%e8%83%bd%e4%bc%98%e4%ba%8e-fmt aria-label="strconv 性能优于 fmt">strconv 性能优于 fmt</a></li><li><a href=#%e9%81%bf%e5%85%8d-string-to-byte-%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label="避免 string to byte 的转换">避免 string to byte 的转换</a></li></ul></li><li><a href=#%e4%bb%a3%e7%a0%81%e9%a3%8e%e6%a0%bc aria-label=代码风格>代码风格</a><ul><li><a href=#%e5%a3%b0%e6%98%8e%e5%88%86%e7%bb%84 aria-label=声明分组>声明分组</a></li><li><a href=#import-%e7%bb%84%e5%86%85%e9%a1%ba%e5%ba%8f aria-label="Import 组内顺序">Import 组内顺序</a></li><li><a href=#%e5%8c%85%e5%90%8d aria-label=包名>包名</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%91%bd%e5%90%8d aria-label=函数命名>函数命名</a></li><li><a href=#%e5%8c%85%e5%af%bc%e5%85%a5%e5%88%ab%e5%90%8d aria-label=包导入别名>包导入别名</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%88%86%e7%bb%84%e4%b8%8e%e6%8e%92%e5%b8%83%e9%a1%ba%e5%ba%8f aria-label=函数分组与排布顺序>函数分组与排布顺序</a></li><li><a href=#%e5%87%8f%e5%b0%91%e5%b5%8c%e5%a5%97 aria-label=减少嵌套>减少嵌套</a></li><li><a href=#%e4%b8%8d%e5%bf%85%e8%a6%81%e7%9a%84-else aria-label="不必要的 else">不必要的 else</a></li><li><a href=#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e aria-label=全局变量声明>全局变量声明</a></li><li><a href=#%e9%9d%9e%e5%af%bc%e5%87%ba%e7%9a%84%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e6%88%96%e8%80%85%e5%b8%b8%e9%87%8f%e4%bb%a5-_-%e5%bc%80%e5%a4%b4 aria-label="非导出的全局变量或者常量以 _ 开头">非导出的全局变量或者常量以 _ 开头</a></li><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e4%b8%ad%e7%9a%84%e5%b5%8c%e5%85%a5%e7%b1%bb%e5%9e%8b aria-label=结构体中的嵌入类型>结构体中的嵌入类型</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%ad%97%e6%ae%b5%e5%90%8d%e6%9d%a5%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84 aria-label=使用字段名来初始化结构>使用字段名来初始化结构</a></li><li><a href=#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e aria-label=局部变量声明>局部变量声明</a></li><li><a href=#nil%e6%98%af%e4%b8%80%e4%b8%aa%e6%9c%89%e6%95%88%e7%9a%84slice aria-label=nil是一个有效的slice>nil是一个有效的slice</a></li><li><a href=#%e7%bc%a9%e5%b0%8f%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label=缩小变量作用域>缩小变量作用域</a></li><li><a href=#%e9%81%bf%e5%85%8d%e8%a3%b8%e5%8f%82%e6%95%b0 aria-label=避免裸参数>避免裸参数</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%8e%9f%e5%a7%8b%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%97%e9%9d%a2%e5%80%bc%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e8%bd%ac%e4%b9%89 aria-label=使用原始字符串字面值，避免使用转义>使用原始字符串字面值，避免使用转义</a></li><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84%e4%bd%93%e5%bc%95%e7%94%a8 aria-label=初始化结构体引用>初始化结构体引用</a></li><li><a href=#%e6%a0%bc%e5%bc%8f%e5%8c%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%94%be%e5%9c%a8-printf-%e5%a4%96%e9%83%a8 aria-label="格式化字符串放在 Printf 外部">格式化字符串放在 Printf 外部</a></li><li><a href=#%e4%b8%ba-printf-%e6%a0%b7%e5%bc%8f%e5%87%bd%e6%95%b0%e5%91%bd%e5%90%8d aria-label="为 Printf 样式函数命名">为 Printf 样式函数命名</a></li></ul></li><li><a href=#%e6%a8%a1%e5%bc%8f aria-label=模式>模式</a><ul><li><a href=#%e6%b5%8b%e8%af%95%e8%a1%a8 aria-label=测试表>测试表</a></li><li><a href=#%e5%8a%9f%e8%83%bd%e9%80%89%e9%a1%b9 aria-label=功能选项>功能选项</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=uber-go-风格指南>Uber Go 风格指南<a hidden class=anchor aria-hidden=true href=#uber-go-风格指南>#</a></h1><ul><li>译文：https://github.com/Allenxuxu/uber-go-guide</li><li>原文：https://github.com/uber-go/guide/blob/master/style.md</li></ul><h2 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>#</a></h2><p>风格是指规范代码的共同约定。风格一词其实是有点用词不当的，因为共同约定的范畴远远不止 gofmt 所做的源代码格式化这些。</p><p>本指南旨在通过详尽描述 Uber 在编写 Go 代码中的注意事项（规定）来解释其中复杂之处。制定这些注意事项（规定）是为了提高代码可维护性同时也让工程师们高效的使用 Go 的特性。</p><p>这份指南最初由 Prashant Varanasi 和 Simon Newton 编写，目的是让一些同事快速上手 Go 。多年来，已经根据其他人的反馈不断修改。</p><p>这份文档记录了我们在 Uber 遵守的 Go 惯用准则。其中很多准则是 Go 的通用准则，其他方面依赖于外部资源：</p><ol><li><a href=https://golang.org/doc/effective_go.html>Effective Go</a></li><li><a href=https://github.com/golang/go/wiki/CodeReviewComments>The Go common mistakes guide</a></li></ol><p>所有的代码都应该通过 <code>golint</code> 和 <code>go vet</code> 检查。我们建议您设置编辑器：</p><ul><li>保存时自动运行 <code>goimports</code></li><li>自动运行 <code>golint</code> 和 <code>go vet</code> 来检查错误</li></ul><p>您可以在这找到关于编辑器设定 Go tools 的相关信息：</p><p><a href=https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins>https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p><h2 id=指南>指南<a hidden class=anchor aria-hidden=true href=#指南>#</a></h2><h3 id=指向接口interface的指针>指向接口（interface）的指针<a hidden class=anchor aria-hidden=true href=#指向接口interface的指针>#</a></h3><p>你基本永远不需要一个指向接口的指针。你应该直接将接口作为值传递，因为接口的底层数据就是指针。</p><p>一个接口包含两个字段：</p><ol><li>类型指针，指向某些特定类型信息的指针。</li><li>数据指针。如果存储数据是一个指针变量，那就直接存储。如果存储数据是一个值变量，那就存储指向该值的指针。</li></ol><p>如果你需要接口方法来修改这些底层数据，那你必须使用指针。</p><h3 id=方法接收器和接口>方法接收器和接口<a hidden class=anchor aria-hidden=true href=#方法接收器和接口>#</a></h3><p>具有值类型接收器的方法可以被值类型和指针类型调用。</p><p>例如，</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>S</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>data</span> <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>S</span>) <span style=color:#a6e22e>Read</span>() <span style=color:#66d9ef>string</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>data</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>S</span>) <span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>str</span> <span style=color:#66d9ef>string</span>) {
  <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>data</span> = <span style=color:#a6e22e>str</span>
}

<span style=color:#a6e22e>sVals</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#a6e22e>S</span>{<span style=color:#ae81ff>1</span>: {<span style=color:#e6db74>&#34;A&#34;</span>}}

<span style=color:#75715e>// 值类型变量只能调用 Read 方法
</span><span style=color:#75715e></span><span style=color:#a6e22e>sVals</span>[<span style=color:#ae81ff>1</span>].<span style=color:#a6e22e>Read</span>()

<span style=color:#75715e>// 无法编译通过:
</span><span style=color:#75715e>//  sVals[0].Write(&#34;test&#34;)
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>sPtrs</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>S</span>{<span style=color:#ae81ff>1</span>: {<span style=color:#e6db74>&#34;A&#34;</span>}}

<span style=color:#75715e>// 指针类型变量可以调用 Read 和 Write 方法：
</span><span style=color:#75715e></span><span style=color:#a6e22e>sPtrs</span>[<span style=color:#ae81ff>1</span>].<span style=color:#a6e22e>Read</span>()
<span style=color:#a6e22e>sPtrs</span>[<span style=color:#ae81ff>1</span>].<span style=color:#a6e22e>Write</span>(<span style=color:#e6db74>&#34;test&#34;</span>)
</code></pre></div><p>同理，即使方法是值类型接收器，接口也可以通过指针来满足调用需求。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>F</span> <span style=color:#66d9ef>interface</span> {
  <span style=color:#a6e22e>f</span>()
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>S1</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>S1</span>) <span style=color:#a6e22e>f</span>() {}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>S2</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>S2</span>) <span style=color:#a6e22e>f</span>() {}

<span style=color:#a6e22e>s1Val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>S1</span>{}
<span style=color:#a6e22e>s1Ptr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>S1</span>{}
<span style=color:#a6e22e>s2Val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>S2</span>{}
<span style=color:#a6e22e>s2Ptr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>S2</span>{}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#a6e22e>F</span>
<span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>s1Val</span>
<span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>s1Ptr</span>
<span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>s2Ptr</span>

<span style=color:#75715e>// 无法编译通过, 因为 s2Val 是一个值类型变量, 并且 f 方法不具有值类型接收器。
</span><span style=color:#75715e>//   i = s2Val
</span></code></pre></div><p>Effective Go 中关于 <a href=https://golang.org/doc/effective_go.html#pointers_vs_values>Pointers vs. Values</a> 写的很棒。</p><h3 id=零值mutexes是有效的>零值Mutexes是有效的<a hidden class=anchor aria-hidden=true href=#零值mutexes是有效的>#</a></h3><p>零值的 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的，所以基本是不需要一个指向 <code>Mutex</code> 的指针的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>mu</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>)
<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mu</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</code></pre></div><p>如果你希望通过指针操作结构体，mutex 可以作为其非指针结构体字段，或者最好直接嵌入结构体中。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>smap</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>

  <span style=color:#a6e22e>data</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newSMap</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>smap</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>smap</span>{
    <span style=color:#a6e22e>data</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>),
  }
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>smap</span>) <span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>k</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
  <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Lock</span>()
  <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Unlock</span>()

  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>k</span>]
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>SMap</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>mu</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>

  <span style=color:#a6e22e>data</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewSMap</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>SMap</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>SMap</span>{
    <span style=color:#a6e22e>data</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>),
  }
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>SMap</span>) <span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>k</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
  <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
  <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()

  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>data</span>[<span style=color:#a6e22e>k</span>]
}
</code></pre></div><h3 id=slices和maps的边界拷贝操作>Slices和Maps的边界拷贝操作<a hidden class=anchor aria-hidden=true href=#slices和maps的边界拷贝操作>#</a></h3><p>切片和 map 包含一个指针来指向底层数据，所以当需要复制他们时需要特别注意。</p><h4 id=接收slices和maps>接收Slices和Maps<a hidden class=anchor aria-hidden=true href=#接收slices和maps>#</a></h4><p>请记住，如果存储了对 slice 或 map 的引用，那么用户是可以对其进行修改。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Driver</span>) <span style=color:#a6e22e>SetTrips</span>(<span style=color:#a6e22e>trips</span> []<span style=color:#a6e22e>Trip</span>) {
  <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>trips</span> = <span style=color:#a6e22e>trips</span>
}

<span style=color:#a6e22e>trips</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>...</span>
<span style=color:#a6e22e>d1</span>.<span style=color:#a6e22e>SetTrips</span>(<span style=color:#a6e22e>trips</span>)

<span style=color:#75715e>// 是想修改 d1.trips 吗？
</span><span style=color:#75715e></span><span style=color:#a6e22e>trips</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#f92672>...</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Driver</span>) <span style=color:#a6e22e>SetTrips</span>(<span style=color:#a6e22e>trips</span> []<span style=color:#a6e22e>Trip</span>) {
  <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>trips</span> = make([]<span style=color:#a6e22e>Trip</span>, len(<span style=color:#a6e22e>trips</span>))
  copy(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>trips</span>, <span style=color:#a6e22e>trips</span>)
}

<span style=color:#a6e22e>trips</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>...</span>
<span style=color:#a6e22e>d1</span>.<span style=color:#a6e22e>SetTrips</span>(<span style=color:#a6e22e>trips</span>)

<span style=color:#75715e>// 修改 trips[0] 并且不影响 d1.trips 。
</span><span style=color:#75715e></span><span style=color:#a6e22e>trips</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#f92672>...</span>
</code></pre></div><h4 id=返回-slices-和-maps>返回 Slices 和 Maps<a hidden class=anchor aria-hidden=true href=#返回-slices-和-maps>#</a></h4><p>同理，谨慎提防用户修改暴露内部状态的 slices 和 maps 。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Stats</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>

  <span style=color:#a6e22e>counters</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>
}

<span style=color:#75715e>// Snapshot 返回当前状态
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Stats</span>) <span style=color:#a6e22e>Snapshot</span>() <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span> {
  <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Lock</span>()
  <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Unlock</span>()

  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>counters</span>
}

<span style=color:#75715e>// snapshot 不再受锁保护了！
</span><span style=color:#75715e></span><span style=color:#a6e22e>snapshot</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stats</span>.<span style=color:#a6e22e>Snapshot</span>()
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Stats</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>

  <span style=color:#a6e22e>counters</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Stats</span>) <span style=color:#a6e22e>Snapshot</span>() <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span> {
  <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Lock</span>()
  <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Unlock</span>()

  <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>counters</span>))
  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>counters</span> {
    <span style=color:#a6e22e>result</span>[<span style=color:#a6e22e>k</span>] = <span style=color:#a6e22e>v</span>
  }
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
}

<span style=color:#75715e>// snapshot 是一分拷贝的内容了
</span><span style=color:#75715e></span><span style=color:#a6e22e>snapshot</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stats</span>.<span style=color:#a6e22e>Snapshot</span>()
</code></pre></div><h3 id=使用-defer-来做清理工作>使用 defer 来做清理工作<a hidden class=anchor aria-hidden=true href=#使用-defer-来做清理工作>#</a></h3><p>使用 defer 来做资源的清理工作，例如文件的关闭和锁的释放。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Lock</span>()
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span> &lt; <span style=color:#ae81ff>10</span> {
  <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Unlock</span>()
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span>
}

<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
<span style=color:#a6e22e>newCount</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span>
<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Unlock</span>()

<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newCount</span>

<span style=color:#75715e>// 当有多处 return 时容易忘记释放锁
</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Lock</span>()
<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Unlock</span>()

<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span> &lt; <span style=color:#ae81ff>10</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span>
}

<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span>

<span style=color:#75715e>// 可读性更高
</span></code></pre></div><p>defer 只有非常小的性能开销，只有当你能证明你的函数执行时间在纳秒级别时才可以不使用它。使用 defer 对代码可读性的提高是非常值得的，因为使用 defer 的成本真的非常小。特别是在一些主要是做内存操作的长函数中，函数中的其他计算操作远比 <code>defer</code> 重要。</p><h3 id=channel-的大小设为-1-还是-none>Channel 的大小设为 1 还是 None<a hidden class=anchor aria-hidden=true href=#channel-的大小设为-1-还是-none>#</a></h3><p>通道的大小通常应该设为 1 或者设为无缓冲类型。默认情况下，通道是无缓冲类型的，大小为 0 。将通道大小设为其他任何数值都应该经过深思熟虑。认真考虑如何确定其大小，是什么阻止了工作中的通道被填满并阻塞了写入操作，以及何种情况会发生这样的现象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 足以满足任何人！
</span><span style=color:#75715e></span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>64</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 大小 为 1
</span><span style=color:#75715e></span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>1</span>) <span style=color:#75715e>// or
</span><span style=color:#75715e>// 无缓冲 channel, 大小为 0
</span><span style=color:#75715e></span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</code></pre></div><h3 id=枚举类型值从-1-开始>枚举类型值从 1 开始<a hidden class=anchor aria-hidden=true href=#枚举类型值从-1-开始>#</a></h3><p>在 Go 中使用枚举的标准方法是声明一个自定义类型并通过 iota 关键字来声明一个 const 组。但是由于 Go 中变量的默认值都为该类型的零值，所以枚举变量的值应该从非零值开始。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Operation</span> <span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>Add</span> <span style=color:#a6e22e>Operation</span> = <span style=color:#66d9ef>iota</span>
  <span style=color:#a6e22e>Subtract</span>
  <span style=color:#a6e22e>Multiply</span>
)

<span style=color:#75715e>// Add=0, Subtract=1, Multiply=2
</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Operation</span> <span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>Add</span> <span style=color:#a6e22e>Operation</span> = <span style=color:#66d9ef>iota</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
  <span style=color:#a6e22e>Subtract</span>
  <span style=color:#a6e22e>Multiply</span>
)

<span style=color:#75715e>// Add=1, Subtract=2, Multiply=3
</span></code></pre></div><p>在某些情况下，从零值开始也是可以的。例如，当零值是我们期望的默认行为时。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>LogOutput</span> <span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>LogToStdout</span> <span style=color:#a6e22e>LogOutput</span> = <span style=color:#66d9ef>iota</span>
  <span style=color:#a6e22e>LogToFile</span>
  <span style=color:#a6e22e>LogToRemote</span>
)

<span style=color:#75715e>// LogToStdout=0, LogToFile=1, LogToRemote=2
</span></code></pre></div><h3 id=错误类型>错误类型<a hidden class=anchor aria-hidden=true href=#错误类型>#</a></h3><p>有很多种方法来声明 errors:</p><ul><li><code>errors.New</code> 声明简单的静态字符串错误信息</li><li><code>fmt.Errorf</code> 声明格式化的字符串错误信息</li><li>为自定义类型实现 <code>Error()</code> 方法</li><li>通过 <code>"pkg/errors".Wrap</code> 包装错误类型</li></ul><p>返回错误时，请考虑以下因素来作出最佳选择：</p><ul><li>这是一个不需要其他额外信息的简单错误吗？如果是，使用<code>error.New</code>。</li><li>客户需要检测并处理此错误吗？如果是，那应该自定义类型，并实现 <code>Error()</code> 方法。</li><li>是否是在传递一个下游函数返回的错误？如果是，请查看<a href=#error-wrapping>error 封装</a>部分。</li><li>其他，使用 <code>fmt.Errorf</code> 。</li></ul><p>如果客户需要检测错误，并且是通过 <code>errors.New</code> 创建的一个简单的错误，请使用var 声明这个错误类型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// package foo
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Open</span>() <span style=color:#66d9ef>error</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;could not open&#34;</span>)
}

<span style=color:#75715e>// package bar
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>use</span>() {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>Open</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>() <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;could not open&#34;</span> {
      <span style=color:#75715e>// handle
</span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> {
      panic(<span style=color:#e6db74>&#34;unknown error&#34;</span>)
    }
  }
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// package foo
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ErrCouldNotOpen</span> = <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;could not open&#34;</span>)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Open</span>() <span style=color:#66d9ef>error</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrCouldNotOpen</span>
}

<span style=color:#75715e>// package bar
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>Open</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>ErrCouldNotOpen</span> {
    <span style=color:#75715e>// handle
</span><span style=color:#75715e></span>  } <span style=color:#66d9ef>else</span> {
    panic(<span style=color:#e6db74>&#34;unknown error&#34;</span>)
  }
}
</code></pre></div><p>如果你有一个错误需要客户端来检测，并且你想向其添加更多信息（例如，它不是一个简单的静态字符串），那么应该声明一个自定义类型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>open</span>(<span style=color:#a6e22e>file</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;file %q not found&#34;</span>, <span style=color:#a6e22e>file</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>use</span>() {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>open</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Contains</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>(), <span style=color:#e6db74>&#34;not found&#34;</span>) {
      <span style=color:#75715e>// handle
</span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> {
      panic(<span style=color:#e6db74>&#34;unknown error&#34;</span>)
    }
  }
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>errNotFound</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>file</span> <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#a6e22e>errNotFound</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;file %q not found&#34;</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>file</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>open</span>(<span style=color:#a6e22e>file</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errNotFound</span>{<span style=color:#a6e22e>file</span>: <span style=color:#a6e22e>file</span>}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>use</span>() {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>open</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>err</span>.(<span style=color:#a6e22e>errNotFound</span>); <span style=color:#a6e22e>ok</span> {
      <span style=color:#75715e>// handle
</span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> {
      panic(<span style=color:#e6db74>&#34;unknown error&#34;</span>)
    }
  }
}
</code></pre></div><p>直接将自定义的错误类型设为导出需要特别小心，因为这意味着他们已经成为包的公开 API 的一部分了。更好的方式是暴露一个匹配函数来检测错误。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// package foo
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>errNotFound</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>file</span> <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#a6e22e>errNotFound</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;file %q not found&#34;</span>, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>file</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>IsNotFoundError</span>(<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>bool</span> {
  <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>err</span>.(<span style=color:#a6e22e>errNotFound</span>)
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ok</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>file</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errNotFound</span>{<span style=color:#a6e22e>file</span>: <span style=color:#a6e22e>file</span>}
}

<span style=color:#75715e>// package bar
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;foo&#34;</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>IsNotFoundError</span>(<span style=color:#a6e22e>err</span>) {
    <span style=color:#75715e>// handle
</span><span style=color:#75715e></span>  } <span style=color:#66d9ef>else</span> {
    panic(<span style=color:#e6db74>&#34;unknown error&#34;</span>)
  }
}
</code></pre></div><h3 id=error-封装>Error 封装<a hidden class=anchor aria-hidden=true href=#error-封装>#</a></h3><p>下面提供三种主要的方法来传递函数调用失败返回的错误：</p><ul><li>如果想要维护原始错误类型并且不需要添加额外的上下文信息，就直接返回原始错误。</li><li>使用 <code>"pkg/errors".Wrap</code> 来增加上下文信息，这样返回的错误信息中就会包含更多的上下文信息，并且通过 <code>"pkg/errors".Cause</code> 可以提取出原始错误信息。</li><li>如果调用方不需要检测或处理特定的错误情况，就直接使用 <code>fmt.Errorf</code> 。</li></ul><p>情况允许的话建议增加更多的上下文信息来代替诸如 <code>"connection refused"</code> 之类模糊的错误信息。返回 <code>"failed to call service foo: connection refused"</code> 用户可以知道更多有用的错误信息。</p><p>在将上下文信息添加到返回的错误时，请避免使用 &ldquo;failed to&rdquo; 之类的短语以保持信息简洁，这些短语描述的状态是显而易见的，并且会随着错误在堆栈中的传递而逐渐堆积：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>store</span>.<span style=color:#a6e22e>New</span>()
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(
        <span style=color:#e6db74>&#34;failed to create new store: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>store</span>.<span style=color:#a6e22e>New</span>()
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(
        <span style=color:#e6db74>&#34;new store: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>failed to x: failed to y: failed to create new store: the error
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>x: y: new store: the error
</code></pre></div><p>但是，如果这个错误信息是会被发送到另一个系统时，必须清楚的表明这是一个错误（例如，日志中 <code>err</code> 标签或者 <code>Failed</code> 前缀）。</p><p>另见 <a href=https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully>Don&rsquo;t just check errors, handle them gracefully</a>。</p><h3 id=处理类型断言失败>处理类型断言失败<a hidden class=anchor aria-hidden=true href=#处理类型断言失败>#</a></h3><p><a href=https://golang.org/ref/spec#Type_assertions>类型断言</a>的单返回值形式在遇到类型错误时会直接 panic 。因此，请始终使用 &ldquo;comma ok&rdquo; 惯用方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span>.(<span style=color:#66d9ef>string</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span>.(<span style=color:#66d9ef>string</span>)
<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
  <span style=color:#75715e>// handle the error gracefully
</span><span style=color:#75715e></span>}
</code></pre></div><h3 id=不要-panic>不要 Panic<a hidden class=anchor aria-hidden=true href=#不要-panic>#</a></h3><p>生产级的代码必须避免 panics 。panics 是级联故障的主要源头。如果错误发生，函数应该返回错误并且允许调用者决定如果处理它。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>foo</span>(<span style=color:#a6e22e>bar</span> <span style=color:#66d9ef>string</span>) {
  <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>bar</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
    panic(<span style=color:#e6db74>&#34;bar must not be empty&#34;</span>)
  }
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
  <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span> {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;USAGE: foo &lt;bar&gt;&#34;</span>)
    <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
  }
  <span style=color:#a6e22e>foo</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>])
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>foo</span>(<span style=color:#a6e22e>bar</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
  <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>bar</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;bar must not be empty&#34;</span>)
  }
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
  <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span> {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;USAGE: foo &lt;bar&gt;&#34;</span>)
    <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
  }
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>foo</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>]); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    panic(<span style=color:#a6e22e>err</span>)
  }
}
</code></pre></div><p>Panic/recover 并不是错误处理策略。程序只有在遇到无法处理的情况下才可以 panic ，例如，nil 引用。程序初始化时是一个例外情况：程序启动时遇到需要终止执行的错误可能会 painc 。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_statusTemplate</span> = <span style=color:#a6e22e>template</span>.<span style=color:#a6e22e>Must</span>(<span style=color:#a6e22e>template</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;name&#34;</span>).<span style=color:#a6e22e>Parse</span>(<span style=color:#e6db74>&#34;_statusHTML&#34;</span>))
</code></pre></div><p>即使是在测试中，也应优先选择 <code>t.Fatal</code> 或 <code>t.FailNow</code> 而非 panic，以确保测试标记为失败。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// func TestFoo(t *testing.T)
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>TempFile</span>(<span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;test&#34;</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  panic(<span style=color:#e6db74>&#34;failed to set up test&#34;</span>)
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// func TestFoo(t *testing.T)
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>TempFile</span>(<span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;test&#34;</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;failed to set up test&#34;</span>)
}
</code></pre></div><h3 id=使用-gouberorgatomic>使用 go.uber.org/atomic<a hidden class=anchor aria-hidden=true href=#使用-gouberorgatomic>#</a></h3><p>Go 的 <code>sync/atomic</code> 包仅仅提供针对原始类型（int32, int64, &mldr;）的原子操作。因此，很容易忘记使用原子操作来读写变量。</p><p><a href=https://godoc.org/go.uber.org/atomic>go.uber.org/atomic</a> 通过隐藏基础类型，使这些操作类型安全。并且，它还提供一个方便的 <code>atomic.Bool</code> 类型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>foo</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>running</span> <span style=color:#66d9ef>int32</span>  <span style=color:#75715e>// atomic
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>foo</span>) <span style=color:#a6e22e>start</span>() {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>SwapInt32</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>running</span>, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
     <span style=color:#75715e>// already running…
</span><span style=color:#75715e></span>     <span style=color:#66d9ef>return</span>
  }
  <span style=color:#75715e>// start the Foo
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>foo</span>) <span style=color:#a6e22e>isRunning</span>() <span style=color:#66d9ef>bool</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>running</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e>// race!
</span><span style=color:#75715e></span>}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>foo</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>running</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Bool</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>foo</span>) <span style=color:#a6e22e>start</span>() {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>running</span>.<span style=color:#a6e22e>Swap</span>(<span style=color:#66d9ef>true</span>) {
     <span style=color:#75715e>// already running…
</span><span style=color:#75715e></span>     <span style=color:#66d9ef>return</span>
  }
  <span style=color:#75715e>// start the Foo
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>foo</span>) <span style=color:#a6e22e>isRunning</span>() <span style=color:#66d9ef>bool</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>running</span>.<span style=color:#a6e22e>Load</span>()
}
</code></pre></div><h2 id=性能>性能<a hidden class=anchor aria-hidden=true href=#性能>#</a></h2><p>性能方面的特定准则，仅适用于热路径。</p><h3 id=strconv-性能优于-fmt>strconv 性能优于 fmt<a hidden class=anchor aria-hidden=true href=#strconv-性能优于-fmt>#</a></h3><p>将原语转换为字符串或从字符串转换时，<code>strconv</code> 速度比 <code>fmt</code> 更快。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
  <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprint</span>(<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Int</span>())
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
  <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Int</span>())
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>BenchmarkFmtSprint-4    143 ns/op    2 allocs/op
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>BenchmarkStrconv-4    64.2 ns/op    1 allocs/op
</code></pre></div><h3 id=避免-string-to-byte-的转换>避免 string to byte 的转换<a hidden class=anchor aria-hidden=true href=#避免-string-to-byte-的转换>#</a></h3><p>不要反复地从字符串字面量创建 byte 切片。相反，执行一次转换后存储结果供后续使用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
  <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;Hello world&#34;</span>))
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>&#34;Hello world&#34;</span>)
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
  <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>data</span>)
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>BenchmarkBad-4   50000000   22.2 ns/op
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>BenchmarkGood-4  500000000   3.25 ns/op
</code></pre></div><h2 id=代码风格>代码风格<a hidden class=anchor aria-hidden=true href=#代码风格>#</a></h2><h3 id=声明分组>声明分组<a hidden class=anchor aria-hidden=true href=#声明分组>#</a></h3><p>Go 支持将相似的声明分组：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;a&#34;</span>
<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;b&#34;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
  <span style=color:#e6db74>&#34;a&#34;</span>
  <span style=color:#e6db74>&#34;b&#34;</span>
)
</code></pre></div><p>分组同样适用于常量、变量和类型的声明：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> = <span style=color:#ae81ff>2</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> = <span style=color:#ae81ff>2</span>

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Area</span> <span style=color:#66d9ef>float64</span>
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Volume</span> <span style=color:#66d9ef>float64</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>1</span>
  <span style=color:#a6e22e>b</span> = <span style=color:#ae81ff>2</span>
)

<span style=color:#66d9ef>var</span> (
  <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>1</span>
  <span style=color:#a6e22e>b</span> = <span style=color:#ae81ff>2</span>
)

<span style=color:#66d9ef>type</span> (
  <span style=color:#a6e22e>Area</span> <span style=color:#66d9ef>float64</span>
  <span style=color:#a6e22e>Volume</span> <span style=color:#66d9ef>float64</span>
)
</code></pre></div><p>仅将相似的声明放在同一组。不相关的声明不要放在同一个组内。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Operation</span> <span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>Add</span> <span style=color:#a6e22e>Operation</span> = <span style=color:#66d9ef>iota</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
  <span style=color:#a6e22e>Subtract</span>
  <span style=color:#a6e22e>Multiply</span>
  <span style=color:#a6e22e>ENV_VAR</span> = <span style=color:#e6db74>&#34;MY_ENV&#34;</span>
)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Operation</span> <span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>Add</span> <span style=color:#a6e22e>Operation</span> = <span style=color:#66d9ef>iota</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
  <span style=color:#a6e22e>Subtract</span>
  <span style=color:#a6e22e>Multiply</span>
)

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ENV_VAR</span> = <span style=color:#e6db74>&#34;MY_ENV&#34;</span>
</code></pre></div><p>声明分组可以在任意位置使用。例如，可以在函数内部使用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>() <span style=color:#66d9ef>string</span> {
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>red</span> = <span style=color:#a6e22e>color</span>.<span style=color:#a6e22e>New</span>(<span style=color:#ae81ff>0xff0000</span>)
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>green</span> = <span style=color:#a6e22e>color</span>.<span style=color:#a6e22e>New</span>(<span style=color:#ae81ff>0x00ff00</span>)
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>blue</span> = <span style=color:#a6e22e>color</span>.<span style=color:#a6e22e>New</span>(<span style=color:#ae81ff>0x0000ff</span>)

  <span style=color:#f92672>...</span>
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>() <span style=color:#66d9ef>string</span> {
  <span style=color:#66d9ef>var</span> (
    <span style=color:#a6e22e>red</span>   = <span style=color:#a6e22e>color</span>.<span style=color:#a6e22e>New</span>(<span style=color:#ae81ff>0xff0000</span>)
    <span style=color:#a6e22e>green</span> = <span style=color:#a6e22e>color</span>.<span style=color:#a6e22e>New</span>(<span style=color:#ae81ff>0x00ff00</span>)
    <span style=color:#a6e22e>blue</span>  = <span style=color:#a6e22e>color</span>.<span style=color:#a6e22e>New</span>(<span style=color:#ae81ff>0x0000ff</span>)
  )

  <span style=color:#f92672>...</span>
}
</code></pre></div><h3 id=import-组内顺序>Import 组内顺序<a hidden class=anchor aria-hidden=true href=#import-组内顺序>#</a></h3><p>import 有两类导入组：</p><ul><li>标准库</li><li>其他</li></ul><p>goimports 默认的分组如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
  <span style=color:#e6db74>&#34;fmt&#34;</span>
  <span style=color:#e6db74>&#34;os&#34;</span>
  <span style=color:#e6db74>&#34;go.uber.org/atomic&#34;</span>
  <span style=color:#e6db74>&#34;golang.org/x/sync/errgroup&#34;</span>
)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
  <span style=color:#e6db74>&#34;fmt&#34;</span>
  <span style=color:#e6db74>&#34;os&#34;</span>

  <span style=color:#e6db74>&#34;go.uber.org/atomic&#34;</span>
  <span style=color:#e6db74>&#34;golang.org/x/sync/errgroup&#34;</span>
)
</code></pre></div><h3 id=包名>包名<a hidden class=anchor aria-hidden=true href=#包名>#</a></h3><p>当为包命名时，请注意如下事项：</p><ul><li>字符全部小写，没有大写或者下划线</li><li>在大多数情况下引入包不需要去重命名</li><li>简单明了，命名需要能够在被导入的地方准确识别</li><li>不要使用复数。例如，<code>net/url</code>, 而不是 <code>net/urls</code></li><li>不要使用“common”，“util”，“shared”或“lib”之类的。这些都是不好的，表达信息不明的名称</li></ul><p>另见 <a href=https://blog.golang.org/package-names>Package Names</a> 和 <a href=https://rakyll.org/style-packages/>Style guideline for Go packages</a></p><h3 id=函数命名>函数命名<a hidden class=anchor aria-hidden=true href=#函数命名>#</a></h3><p>我们遵循 Go 社区关于使用的 <a href=https://golang.org/doc/effective_go.html#mixed-caps>MixedCaps for function names</a>。有一种情况例外，对相关的测试用例进行分组时，函数名可能包含下划线，如: <code>TestMyFunction_WhatIsBeingTested</code>。</p><h3 id=包导入别名>包导入别名<a hidden class=anchor aria-hidden=true href=#包导入别名>#</a></h3><p>如果包的名称与导入路径的最后一个元素不匹配，那必须使用导入别名。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
  <span style=color:#e6db74>&#34;net/http&#34;</span>

  <span style=color:#a6e22e>client</span> <span style=color:#e6db74>&#34;example.com/client-go&#34;</span>
  <span style=color:#a6e22e>trace</span> <span style=color:#e6db74>&#34;example.com/trace/v2&#34;</span>
)
</code></pre></div><p>在其他情况下，除非导入的包名之间有直接冲突，否则应避免使用导入别名。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
  <span style=color:#e6db74>&#34;fmt&#34;</span>
  <span style=color:#e6db74>&#34;os&#34;</span>


  <span style=color:#a6e22e>nettrace</span> <span style=color:#e6db74>&#34;golang.net/x/trace&#34;</span>
)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
  <span style=color:#e6db74>&#34;fmt&#34;</span>
  <span style=color:#e6db74>&#34;os&#34;</span>
  <span style=color:#e6db74>&#34;runtime/trace&#34;</span>

  <span style=color:#a6e22e>nettrace</span> <span style=color:#e6db74>&#34;golang.net/x/trace&#34;</span>
)
</code></pre></div><h3 id=函数分组与排布顺序>函数分组与排布顺序<a hidden class=anchor aria-hidden=true href=#函数分组与排布顺序>#</a></h3><ul><li>函数应该粗略的按照调用顺序来排布</li><li>同一文件中的函数应该按照接收器的类型来分组排布</li></ul><p>所以，公开的函数应排布在文件首，并在 struct、const 和 var 定义之后。</p><p>newXYZ()/ NewXYZ() 之类的函数应该排布在声明类型之后，具有接收器的其余方法之前。</p><p>因为函数是按接收器类别分组的，所以普通工具函数应排布在文件末尾。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>something</span>) <span style=color:#a6e22e>Cost</span>() {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>calcCost</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>weights</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>something</span> <span style=color:#66d9ef>struct</span>{ <span style=color:#f92672>...</span> }

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>calcCost</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>[]) <span style=color:#66d9ef>int</span> {<span style=color:#f92672>...</span>}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>something</span>) <span style=color:#a6e22e>Stop</span>() {<span style=color:#f92672>...</span>}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newSomething</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>something</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>something</span>{}
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>something</span> <span style=color:#66d9ef>struct</span>{ <span style=color:#f92672>...</span> }

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newSomething</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>something</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>something</span>{}
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>something</span>) <span style=color:#a6e22e>Cost</span>() {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>calcCost</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>weights</span>)
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>something</span>) <span style=color:#a6e22e>Stop</span>() {<span style=color:#f92672>...</span>}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>calcCost</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>[]) <span style=color:#66d9ef>int</span> {<span style=color:#f92672>...</span>}
</code></pre></div><h3 id=减少嵌套>减少嵌套<a hidden class=anchor aria-hidden=true href=#减少嵌套>#</a></h3><p>代码应该通过尽可能地先处理错误情况/特殊情况，并且及早返回或继续下一循环来减少嵌套。尽量减少嵌套于多个级别的代码数量。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>data</span> {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>F1</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
    <span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>process</span>(<span style=color:#a6e22e>v</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Call</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
      <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Send</span>()
    } <span style=color:#66d9ef>else</span> {
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
    }
  } <span style=color:#66d9ef>else</span> {
    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Invalid v: %v&#34;</span>, <span style=color:#a6e22e>v</span>)
  }
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>data</span> {
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>F1</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> {
    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Invalid v: %v&#34;</span>, <span style=color:#a6e22e>v</span>)
    <span style=color:#66d9ef>continue</span>
  }

  <span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>process</span>(<span style=color:#a6e22e>v</span>)
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Call</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
  }
  <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Send</span>()
}
</code></pre></div><h3 id=不必要的-else>不必要的 else<a hidden class=anchor aria-hidden=true href=#不必要的-else>#</a></h3><p>如果一个变量在 if 的两个分支中都设置了，那应该使用单个 if 。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> {
  <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>100</span>
} <span style=color:#66d9ef>else</span> {
  <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>10</span>
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>10</span>
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> {
  <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>100</span>
}
</code></pre></div><h3 id=全局变量声明>全局变量声明<a hidden class=anchor aria-hidden=true href=#全局变量声明>#</a></h3><p>在顶层使用标准 var 关键字声明变量时，不要显式指定类型，除非它与表达式的返回类型不同。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_s</span> <span style=color:#66d9ef>string</span> = <span style=color:#a6e22e>F</span>()

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>F</span>() <span style=color:#66d9ef>string</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;A&#34;</span> }
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_s</span> = <span style=color:#a6e22e>F</span>()
<span style=color:#75715e>// F 已经明确声明返回一个字符串类型，我们没有必要显式指定 _s 的类型
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>F</span>() <span style=color:#66d9ef>string</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;A&#34;</span> }
</code></pre></div><p>如果表达式的返回类型与所需的类型不完全匹配，请显示指定类型。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>myError</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>myError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;error&#34;</span> }

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>F</span>() <span style=color:#a6e22e>myError</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>myError</span>{} }

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_e</span> <span style=color:#66d9ef>error</span> = <span style=color:#a6e22e>F</span>()
<span style=color:#75715e>// F 返回一个 myError 类型的实例，但是我们要 error 类型
</span></code></pre></div><h3 id=非导出的全局变量或者常量以-_-开头>非导出的全局变量或者常量以 _ 开头<a hidden class=anchor aria-hidden=true href=#非导出的全局变量或者常量以-_-开头>#</a></h3><p>非导出的全局变量和常量前面加上前缀 <code>_</code>，以明确表示它们是全局符号。</p><p>例外：未导出的错误类型变量，应以 <code>err</code> 开头。</p><p>解释：顶级（全局）变量和常量具有包范围作用域。使用通用名称命名，可能在其他文件中不经意间地使用一个错误值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// foo.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>defaultPort</span> = <span style=color:#ae81ff>8080</span>
  <span style=color:#a6e22e>defaultUser</span> = <span style=color:#e6db74>&#34;user&#34;</span>
)

<span style=color:#75715e>// bar.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Bar</span>() {
  <span style=color:#a6e22e>defaultPort</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>9090</span>
  <span style=color:#f92672>...</span>
  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Default port&#34;</span>, <span style=color:#a6e22e>defaultPort</span>)

  <span style=color:#75715e>// We will not see a compile error if the first line of
</span><span style=color:#75715e></span>  <span style=color:#75715e>// Bar() is deleted.
</span><span style=color:#75715e></span>}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// foo.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>_defaultPort</span> = <span style=color:#ae81ff>8080</span>
  <span style=color:#a6e22e>_defaultUser</span> = <span style=color:#e6db74>&#34;user&#34;</span>
)
</code></pre></div><h3 id=结构体中的嵌入类型>结构体中的嵌入类型<a hidden class=anchor aria-hidden=true href=#结构体中的嵌入类型>#</a></h3><p>嵌入式类型（例如 mutex ）应该放置在结构体字段列表的顶部，并且必须以空行与常规字段隔开。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Client</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>version</span> <span style=color:#66d9ef>int</span>
  <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Client</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Client</span>

  <span style=color:#a6e22e>version</span> <span style=color:#66d9ef>int</span>
}
</code></pre></div><h3 id=使用字段名来初始化结构>使用字段名来初始化结构<a hidden class=anchor aria-hidden=true href=#使用字段名来初始化结构>#</a></h3><p>初始化结构体时，必须指定字段名称。<code>go vet</code> 强制执行。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>User</span>{<span style=color:#e6db74>&#34;John&#34;</span>, <span style=color:#e6db74>&#34;Doe&#34;</span>, <span style=color:#66d9ef>true</span>}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>User</span>{
    <span style=color:#a6e22e>FirstName</span>: <span style=color:#e6db74>&#34;John&#34;</span>,
    <span style=color:#a6e22e>LastName</span>: <span style=color:#e6db74>&#34;Doe&#34;</span>,
    <span style=color:#a6e22e>Admin</span>: <span style=color:#66d9ef>true</span>,
}
</code></pre></div><p>例外：在测试文件中，如果结构体只有3个或更少的字段，则可以省略字段名称。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>tests</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>struct</span>{
}{
  <span style=color:#a6e22e>op</span> <span style=color:#a6e22e>Operation</span>
  <span style=color:#a6e22e>want</span> <span style=color:#66d9ef>string</span>
}{
  {<span style=color:#a6e22e>Add</span>, <span style=color:#e6db74>&#34;add&#34;</span>},
  {<span style=color:#a6e22e>Subtract</span>, <span style=color:#e6db74>&#34;subtract&#34;</span>},
}
</code></pre></div><h3 id=局部变量声明>局部变量声明<a hidden class=anchor aria-hidden=true href=#局部变量声明>#</a></h3><p>如果声明局部变量时需要明确设值，应使用短变量声明形式（:=）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> = <span style=color:#e6db74>&#34;foo&#34;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;foo&#34;</span>
</code></pre></div><p>但是，在某些情况下，使用 var 关键字声明变量，默认的初始化值会更清晰。例如，声明空切片。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>list</span> []<span style=color:#66d9ef>int</span>) {
  <span style=color:#a6e22e>filtered</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>list</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &gt; <span style=color:#ae81ff>10</span> {
      <span style=color:#a6e22e>filtered</span> = append(<span style=color:#a6e22e>filtered</span>, <span style=color:#a6e22e>v</span>)
    }
  }
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>list</span> []<span style=color:#66d9ef>int</span>) {
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>filtered</span> []<span style=color:#66d9ef>int</span>
  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>list</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> &gt; <span style=color:#ae81ff>10</span> {
      <span style=color:#a6e22e>filtered</span> = append(<span style=color:#a6e22e>filtered</span>, <span style=color:#a6e22e>v</span>)
    }
  }
}
</code></pre></div><h3 id=nil是一个有效的slice>nil是一个有效的slice<a hidden class=anchor aria-hidden=true href=#nil是一个有效的slice>#</a></h3><p>nil 是一个有效的长度为 0 的 slice，这意味着：</p><ul><li><p>不应明确返回长度为零的切片，而应该直接返回 nil 。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
  <span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>int</span>{}
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div></li><li><p>若要检查切片是否为空，始终使用 <code>len(s) == 0</code> ，不要与 nil 比较来检查。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isEmpty</span>(<span style=color:#a6e22e>s</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>bool</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isEmpty</span>(<span style=color:#a6e22e>s</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>bool</span> {
  <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>s</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
}
</code></pre></div></li><li><p>零值切片（通过 var 声明的切片）可直接使用，无需调用 make 创建。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>nums</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{}
<span style=color:#75715e>// or, nums := make([]int)
</span><span style=color:#75715e></span>  
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>add1</span> {
  <span style=color:#a6e22e>nums</span> = append(<span style=color:#a6e22e>nums</span>, <span style=color:#ae81ff>1</span>)
}
  
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>add2</span> {
  <span style=color:#a6e22e>nums</span> = append(<span style=color:#a6e22e>nums</span>, <span style=color:#ae81ff>2</span>)
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>
  
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>add1</span> {
  <span style=color:#a6e22e>nums</span> = append(<span style=color:#a6e22e>nums</span>, <span style=color:#ae81ff>1</span>)
}
  
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>add2</span> {
  <span style=color:#a6e22e>nums</span> = append(<span style=color:#a6e22e>nums</span>, <span style=color:#ae81ff>2</span>)
}
</code></pre></div></li></ul><h3 id=缩小变量作用域>缩小变量作用域<a hidden class=anchor aria-hidden=true href=#缩小变量作用域>#</a></h3><p>如果有可能，尽量缩小变量作用范围，除非这样与减少嵌套的规则冲突。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>WriteFile</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>data</span>, <span style=color:#ae81ff>0644</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
 <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>WriteFile</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>data</span>, <span style=color:#ae81ff>0644</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
 <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}
</code></pre></div><p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadFile</span>(<span style=color:#a6e22e>name</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>Decode</span>(<span style=color:#a6e22e>data</span>)
  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
  }

  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>cfg</span>)
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
} <span style=color:#66d9ef>else</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadFile</span>(<span style=color:#a6e22e>name</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}

<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>Decode</span>(<span style=color:#a6e22e>data</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}

<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>cfg</span>)
<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</code></pre></div><h3 id=避免裸参数>避免裸参数<a hidden class=anchor aria-hidden=true href=#避免裸参数>#</a></h3><p>函数调用中的裸参数可能会降低代码可读性。所以当参数名称的含义不明显时，请为参数添加 C 样式的注释（/* … */）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// func printInfo(name string, isLocal, done bool)
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>printInfo</span>(<span style=color:#e6db74>&#34;foo&#34;</span>, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// func printInfo(name string, isLocal, done bool)
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>printInfo</span>(<span style=color:#e6db74>&#34;foo&#34;</span>, <span style=color:#66d9ef>true</span> <span style=color:#75715e>/* isLocal */</span>, <span style=color:#66d9ef>true</span> <span style=color:#75715e>/* done */</span>)
</code></pre></div><p>上面更好的作法是将 bool 类型替换为自定义类型，从而使代码更易读且类型安全。将来需要拓展时，该参数也可以不止两个状态（true/false）。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Region</span> <span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>UnknownRegion</span> <span style=color:#a6e22e>Region</span> = <span style=color:#66d9ef>iota</span>
  <span style=color:#a6e22e>Local</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Status</span> <span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>const</span> (
  <span style=color:#a6e22e>StatusReady</span> = <span style=color:#66d9ef>iota</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
  <span style=color:#a6e22e>StatusDone</span>
  <span style=color:#75715e>// 也许将来我们会有 StatusInProgress。
</span><span style=color:#75715e></span>)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>printInfo</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>region</span> <span style=color:#a6e22e>Region</span>, <span style=color:#a6e22e>status</span> <span style=color:#a6e22e>Status</span>)
</code></pre></div><h3 id=使用原始字符串字面值避免使用转义>使用原始字符串字面值，避免使用转义<a hidden class=anchor aria-hidden=true href=#使用原始字符串字面值避免使用转义>#</a></h3><p>Go 支持原始字符串字面值，可以多行并包含引号。使用它可以避免使用肉眼阅读较为困难的手工转义的字符串。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>wantError</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;unknown name:\&#34;test\&#34;&#34;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>wantError</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>`unknown error:&#34;test&#34;`</span>
</code></pre></div><h3 id=初始化结构体引用>初始化结构体引用<a hidden class=anchor aria-hidden=true href=#初始化结构体引用>#</a></h3><p>在初始化结构引用时，使用 <code>&T{}</code> 而非 <code>new(T)</code>，以使其与结构体初始化方式保持一致。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>sval</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>T</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;foo&#34;</span>}

<span style=color:#75715e>// 定义方式不一致
</span><span style=color:#75715e></span><span style=color:#a6e22e>sptr</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>T</span>)
<span style=color:#a6e22e>sptr</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#e6db74>&#34;bar&#34;</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>sval</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>T</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;foo&#34;</span>}

<span style=color:#a6e22e>sptr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>T</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;bar&#34;</span>}
</code></pre></div><h3 id=格式化字符串放在-printf-外部>格式化字符串放在 Printf 外部<a hidden class=anchor aria-hidden=true href=#格式化字符串放在-printf-外部>#</a></h3><p>如果为 Printf-style 函数声明格式化字符串，将格式化字符串放在函数外面 ，并将其设置为 const 常量。</p><p>这有助于 <code>go vet</code> 对格式字符串进行静态分析。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;unexpected values %v, %v\n&#34;</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#a6e22e>msg</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>msg</span> = <span style=color:#e6db74>&#34;unexpected values %v, %v\n&#34;</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#a6e22e>msg</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</code></pre></div><h3 id=为-printf-样式函数命名>为 Printf 样式函数命名<a hidden class=anchor aria-hidden=true href=#为-printf-样式函数命名>#</a></h3><p>声明 Printf-style 函数时，请确保 <code>go vet</code> 可以检查它的格式化字符串。</p><p>这意味着应尽可能使用预定义的 Printf-style 函数名称。<code>go vet</code> 默认会检查它们。更多相关信息，请参见 <a href=https://golang.org/cmd/vet/#hdr-Printf_family>Printf系列</a>。</p><p>如果不能使用预定义的名称，请以 f 结尾：Wrapf，而非 Wrap。因为 <code>go vet</code> 可以指定检查特定的 Printf 样式名称，但名称必须以 f 结尾。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ go vet -printfuncs<span style=color:#f92672>=</span>wrapf,statusf
...
</code></pre></div><p>另见 <a href=https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/>go vet: Printf family check</a></p><h2 id=模式>模式<a hidden class=anchor aria-hidden=true href=#模式>#</a></h2><h3 id=测试表>测试表<a hidden class=anchor aria-hidden=true href=#测试表>#</a></h3><p>在核心测试逻辑重复时，将表驱动测试与子测试一起使用，以避免重复代码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// func TestSplitHostPort(t *testing.T)
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>host</span>, <span style=color:#a6e22e>port</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>SplitHostPort</span>(<span style=color:#e6db74>&#34;192.0.2.0:8000&#34;</span>)
<span style=color:#a6e22e>require</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span>)
<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;192.0.2.0&#34;</span>, <span style=color:#a6e22e>host</span>)
<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;8000&#34;</span>, <span style=color:#a6e22e>port</span>)

<span style=color:#a6e22e>host</span>, <span style=color:#a6e22e>port</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>SplitHostPort</span>(<span style=color:#e6db74>&#34;192.0.2.0:http&#34;</span>)
<span style=color:#a6e22e>require</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span>)
<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;192.0.2.0&#34;</span>, <span style=color:#a6e22e>host</span>)
<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;http&#34;</span>, <span style=color:#a6e22e>port</span>)

<span style=color:#a6e22e>host</span>, <span style=color:#a6e22e>port</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>SplitHostPort</span>(<span style=color:#e6db74>&#34;:8000&#34;</span>)
<span style=color:#a6e22e>require</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span>)
<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>host</span>)
<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;8000&#34;</span>, <span style=color:#a6e22e>port</span>)

<span style=color:#a6e22e>host</span>, <span style=color:#a6e22e>port</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>SplitHostPort</span>(<span style=color:#e6db74>&#34;1:8&#34;</span>)
<span style=color:#a6e22e>require</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span>)
<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;1&#34;</span>, <span style=color:#a6e22e>host</span>)
<span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#e6db74>&#34;8&#34;</span>, <span style=color:#a6e22e>port</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// func TestSplitHostPort(t *testing.T)
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>tests</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>struct</span>{
  <span style=color:#a6e22e>give</span>     <span style=color:#66d9ef>string</span>
  <span style=color:#a6e22e>wantHost</span> <span style=color:#66d9ef>string</span>
  <span style=color:#a6e22e>wantPort</span> <span style=color:#66d9ef>string</span>
}{
  {
    <span style=color:#a6e22e>give</span>:     <span style=color:#e6db74>&#34;192.0.2.0:8000&#34;</span>,
    <span style=color:#a6e22e>wantHost</span>: <span style=color:#e6db74>&#34;192.0.2.0&#34;</span>,
    <span style=color:#a6e22e>wantPort</span>: <span style=color:#e6db74>&#34;8000&#34;</span>,
  },
  {
    <span style=color:#a6e22e>give</span>:     <span style=color:#e6db74>&#34;192.0.2.0:http&#34;</span>,
    <span style=color:#a6e22e>wantHost</span>: <span style=color:#e6db74>&#34;192.0.2.0&#34;</span>,
    <span style=color:#a6e22e>wantPort</span>: <span style=color:#e6db74>&#34;http&#34;</span>,
  },
  {
    <span style=color:#a6e22e>give</span>:     <span style=color:#e6db74>&#34;:8000&#34;</span>,
    <span style=color:#a6e22e>wantHost</span>: <span style=color:#e6db74>&#34;&#34;</span>,
    <span style=color:#a6e22e>wantPort</span>: <span style=color:#e6db74>&#34;8000&#34;</span>,
  },
  {
    <span style=color:#a6e22e>give</span>:     <span style=color:#e6db74>&#34;1:8&#34;</span>,
    <span style=color:#a6e22e>wantHost</span>: <span style=color:#e6db74>&#34;1&#34;</span>,
    <span style=color:#a6e22e>wantPort</span>: <span style=color:#e6db74>&#34;8&#34;</span>,
  },
}

<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>tt</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tests</span> {
  <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>give</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
    <span style=color:#a6e22e>host</span>, <span style=color:#a6e22e>port</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>SplitHostPort</span>(<span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>give</span>)
    <span style=color:#a6e22e>require</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span>)
    <span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>wantHost</span>, <span style=color:#a6e22e>host</span>)
    <span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>wantPort</span>, <span style=color:#a6e22e>port</span>)
  })
}
</code></pre></div><p>测试表使得向错误消息注入上下文信息，减少重复的逻辑，添加新的测试用例变得更加容易。</p><p>我们遵循这样的约定：将结构体切片称为 tests。 每个测试用例称为 tt 。此外，我们鼓励使用 give 和 want 前缀说明每个测试用例的输入和输出值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>tests</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>struct</span>{
  <span style=color:#a6e22e>give</span>     <span style=color:#66d9ef>string</span>
  <span style=color:#a6e22e>wantHost</span> <span style=color:#66d9ef>string</span>
  <span style=color:#a6e22e>wantPort</span> <span style=color:#66d9ef>string</span>
}{
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>tt</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tests</span> {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><h3 id=功能选项>功能选项<a hidden class=anchor aria-hidden=true href=#功能选项>#</a></h3><p>功能选项是一种模式，声明一个不透明 Option 类型，该类型记录某些内部结构体的信息。您的函数接受这些不定数量的选项参数，并将选项参数上的信息作用于内部结构上。</p><p>此模式可用于扩展构造函数和实现其他公共 API 中的可选参数，特别是这些参数已经有三个或者超过三个的情况下。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// package db
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Connect</span>(
  <span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>,
  <span style=color:#a6e22e>timeout</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>,
  <span style=color:#a6e22e>caching</span> <span style=color:#66d9ef>bool</span>,
) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Connection</span>, <span style=color:#66d9ef>error</span>) {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}

<span style=color:#75715e>// Timeout and caching must always be provided,
</span><span style=color:#75715e>// even if the user wants to use the default.
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>DefaultTimeout</span>, <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>DefaultCaching</span>)
<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>newTimeout</span>, <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>DefaultCaching</span>)
<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>DefaultTimeout</span>, <span style=color:#66d9ef>false</span> <span style=color:#75715e>/* caching */</span>)
<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>newTimeout</span>, <span style=color:#66d9ef>false</span> <span style=color:#75715e>/* caching */</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>options</span> <span style=color:#66d9ef>struct</span> {
  <span style=color:#a6e22e>timeout</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>
  <span style=color:#a6e22e>caching</span> <span style=color:#66d9ef>bool</span>
}

<span style=color:#75715e>// Option overrides behavior of Connect.
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Option</span> <span style=color:#66d9ef>interface</span> {
  <span style=color:#a6e22e>apply</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>options</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>optionFunc</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>options</span>)

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>f</span> <span style=color:#a6e22e>optionFunc</span>) <span style=color:#a6e22e>apply</span>(<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>options</span>) {
  <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>o</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>) <span style=color:#a6e22e>Option</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>optionFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>options</span>) {
    <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>timeout</span> = <span style=color:#a6e22e>t</span>
  })
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithCaching</span>(<span style=color:#a6e22e>cache</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>Option</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>optionFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>options</span>) {
    <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>caching</span> = <span style=color:#a6e22e>cache</span>
  })
}

<span style=color:#75715e>// Connect creates a connection.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Connect</span>(
  <span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>,
  <span style=color:#a6e22e>opts</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>Option</span>,
) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Connection</span>, <span style=color:#66d9ef>error</span>) {
  <span style=color:#a6e22e>options</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>options</span>{
    <span style=color:#a6e22e>timeout</span>: <span style=color:#a6e22e>defaultTimeout</span>,
    <span style=color:#a6e22e>caching</span>: <span style=color:#a6e22e>defaultCaching</span>,
  }

  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>o</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>opts</span> {
    <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>apply</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>options</span>)
  }

  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}

<span style=color:#75715e>// Options must be provided only if needed.
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>addr</span>)
<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>newTimeout</span>))
<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>WithCaching</span>(<span style=color:#66d9ef>false</span>))
<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Connect</span>(
  <span style=color:#a6e22e>addr</span>,
  <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>WithCaching</span>(<span style=color:#66d9ef>false</span>),
  <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>newTimeout</span>),
)
</code></pre></div><p>另见，</p><ul><li><a href=https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html>Self-referential functions and the design of options</a></li><li><a href=https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis>Functional options for friendly APIs</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://mogutou.xyz/tags/go/>Go</a></li></ul><nav class=paginav><a class=prev href=https://mogutou.xyz/posts/open-source/gev-protocol/><span class=title>« Prev Page</span><br><span>[gev] 自定义协议支持</span></a>
<a class=next href=https://mogutou.xyz/posts/open-source/gev-benchmark/><span class=title>Next Page »</span><br><span>Go 网络库并发吞吐量测试</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Uber Go 风格指南 on twitter" href="https://twitter.com/intent/tweet/?text=Uber%20Go%20%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97&url=https%3a%2f%2fmogutou.xyz%2fposts%2fgo%2fuber-go-guide%2f&hashtags=Go"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Uber Go 风格指南 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmogutou.xyz%2fposts%2fgo%2fuber-go-guide%2f&title=Uber%20Go%20%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97&summary=Uber%20Go%20%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97&source=https%3a%2f%2fmogutou.xyz%2fposts%2fgo%2fuber-go-guide%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Uber Go 风格指南 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmogutou.xyz%2fposts%2fgo%2fuber-go-guide%2f&title=Uber%20Go%20%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Uber Go 风格指南 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmogutou.xyz%2fposts%2fgo%2fuber-go-guide%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Uber Go 风格指南 on whatsapp" href="https://api.whatsapp.com/send?text=Uber%20Go%20%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97%20-%20https%3a%2f%2fmogutou.xyz%2fposts%2fgo%2fuber-go-guide%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Uber Go 风格指南 on telegram" href="https://telegram.me/share/url?text=Uber%20Go%20%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97&url=https%3a%2f%2fmogutou.xyz%2fposts%2fgo%2fuber-go-guide%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=Allenxuxu/Allenxuxu.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2021 <a href=https://mogutou.xyz/>徐旭 的博客</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>