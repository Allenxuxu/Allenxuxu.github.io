<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go | 徐旭 的博客</title><meta name=keywords content><meta name=description content><meta name=author content="徐旭"><link rel=canonical href=https://allenxuxu.github.io/tags/go/><link crossorigin=anonymous href=/assets/css/stylesheet.min.04512c372388e08b5118f5b117b2d3efef4ddae52017e16085c8d8d4e361c43d.css integrity="sha256-BFEsNyOI4ItRGPWxF7LT7+9N2uUgF+FghcjY1ONhxD0=" rel="preload stylesheet" as=style><link rel=icon href=https://allenxuxu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://allenxuxu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://allenxuxu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://allenxuxu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://allenxuxu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><link rel=alternate type=application/rss+xml href=https://allenxuxu.github.io/tags/go/index.xml><meta property="og:title" content="Go"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://allenxuxu.github.io/tags/go/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://allenxuxu.github.io/ accesskey=h title="徐旭 的博客 (Alt + H)">徐旭 的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://allenxuxu.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://allenxuxu.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://allenxuxu.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://allenxuxu.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://allenxuxu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://allenxuxu.github.io/tags/>Tags</a></div><h1>Go</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>Go1.16 embed 和 Vue</h2></header><section class=entry-content><p>vue 相关代码： https://github.com/Allenxuxu/ginvue
先全局安装下 vue cli 并创建一个 demo 项目
npm install -g @vue/cli vue create web 然后我们进入 web 目录，修改生成的 package.json 文件调整一下 build 生成的静态文件目录。
–dest 是指定输出的目录
**–no-clean 是让他不要每次覆盖我们的目录，因为后面我们会放一个 go 文件到那个目录。 **
"build": "vue-cli-service build --no-clean --dest ../static", 再新增一个 vue.config.js 文件来修改下 , 这里将 production 的 publicPath 修改成带一个前缀 /ui/ , 这里主要就是为了后面我们的go 代码路由设置方便，所有的前端静态文件请求都带上 /ui 前缀，和后端 API 接口带 /api 前缀区分。
module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/ui/' : '/' } 最后我们再 web 目录运行 npm run build，会生成一个 static 目录（也就是我们修改的 package....</p></section><footer class=entry-footer>April 20, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go1.16 embed 和 Vue" href=https://allenxuxu.github.io/practice/gin-vue/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Golang slice map channel 小技巧</h2></header><section class=entry-content><p>Slice vs Array Slice 和 Array 是不同的类型 package main func main() { s := make([]int, 100) printSlice(s) var a [100]int printArray(a) } func printSlice(s []int) { println(len(s)) // 100 println(cap(s)) // 100 } func printArray(a [100]int) { println(len(a)) // 100 println(cap(a)) // 100 } Slice 结构体
type slice struct { array unsafe.Pointer len int cap int } 下面的汇编表明，当类型是 slice 的时候，打印 len 或者 cap 的时候，会去栈上取数据:
MOVQ 0x28(SP), AX MOVQ AX, 0x8(SP) CALL 0xbfc [1:5]R_CALL:runtime....</p></section><footer class=entry-footer>April 17, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Golang slice map channel 小技巧" href=https://allenxuxu.github.io/go/go-slice-map-channel/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>golang protobuf 字段为零值时 json 序列化忽略问题</h2></header><section class=entry-content><p>protoc 编译生成的 pb.go 文件，默认情况下 tag 中会设置 json 忽略零值的返回属性 omitempty。
type Message struct { Header map[string]string `protobuf:"bytes,1,rep,name=header,proto3" json:"header,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"` Body []byte `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } 一个比较 hack 的方式，是在 pb.go 文件生成后，手动去删掉 omitempty 。每次手动去删除，比较麻烦且容易出错，下面提供一个 Makefile ，每次生成 pb.go 的时候就去删除 omitempty 。
proto: protoc --proto_path=. --go_out=. --micro_out=. config/config.proto ls config/*.pb.go | xargs -n1 -IX bash -c 'sed s/,omitempty// X > X.tmp && mv X{.tmp,}' proto 目标的第一个命令是调用 protoc 根据 config/config....</p></section><footer class=entry-footer>June 2, 2020&nbsp;·&nbsp;1 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to golang protobuf 字段为零值时 json 序列化忽略问题" href=https://allenxuxu.github.io/practice/protobuf-json/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>go chan 实用示例</h2></header><section class=entry-content><p>尝试发送 select { case c &lt;- struct{}{}: default: fmt.Println("chan 已满，发送不成功") } 尝试接收 select { case v := &lt;- c: default: fmt.Println("chan 中没有信息，接收不成功") } 标准编译器对尝试发送和尝试接收代码块做了特别的优化，使得它们的执行效率比多 case分支的普通 select代码块执行效率高得多。
无阻塞的检查一个 chan 是否关闭 假设我们可以保证没有任何协程会向一个通道发送数据，则我们可以使用下面的代码来（并发安全地）检查此通道是否已经关闭，此检查不会阻塞当前协程。
func IsClosed(c chan struct{}) bool { select { case &lt;-c: return true default: } return false } 最快回应 package main import ( "fmt" "math/rand" "time" ) func source(c chan&lt;- int, id int) { rb := rand....</p></section><footer class=entry-footer>May 30, 2020&nbsp;·&nbsp;1 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to go chan 实用示例" href=https://allenxuxu.github.io/go/go-channel/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>二叉堆与堆排序</h2></header><section class=entry-content><p>二叉堆是一组能够用堆有序的完全二叉树排序的元素，一般用数组来存储。
大顶堆， 每个结点的值都大于或等于其左右孩子结点的值，其顶部为最大值。
小顶堆，每个结点的值都小于或等于其左右孩子结点的值，其顶部为最小值。
二叉堆 性质 根节点在数组中的位置是 1 左边子节点 2i 右子节点 2i+1 父节点 i / 2 最后一个非叶子节点为 len / 2 根节点在数组中的位置是 0 左子节点 2i + 1 右边子节点 2i+ 2 父节点的下标是 (i − 1) / 2 最后一个非叶子节点为 len / 2 - 1 图片来自知乎
实现 构造二叉堆 找到最后一个非叶子节点 ( len / 2 或者 len / 2 - 1） 从最后一个非叶子节点下标索引开始递减，逐个下沉 插入节点 在数组的最末尾插入新节点 将最后一个节点上浮，时间复杂度为O(log n) 比较当前节点与父节点 不满足 堆性质* *则交换 删除根节点 删除根节点用于堆排序...</p></section><footer class=entry-footer>May 30, 2020&nbsp;·&nbsp;2 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to 二叉堆与堆排序" href=https://allenxuxu.github.io/algorithm/heap/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>二叉树的遍历模版（递归，迭代）</h2></header><section class=entry-content><p>图片来自 leetcode
深度优先遍历（dfs） 前序遍历 中序遍历 后序遍历 广度优先遍历（bfs） type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 深度优先遍历 递归 递归版本，代码比较简单，只需改变 append 数据的位置即可。
前序遍历 func preorderTraversal(root *TreeNode) []int { var ret []int helper(root, &ret) return ret } func helper(root *TreeNode, data *[]int) { if root == nil { return } *data = append(*data, root.Val) helper(root.Left, data) helper(root.Right, data) } 中序遍历 func inorderTraversal(root *TreeNode) []int { var ret []int helper(root, &ret) return ret } func helper(root *TreeNode, data *[]int) { if root == nil { return } helper(root....</p></section><footer class=entry-footer>April 26, 2020&nbsp;·&nbsp;3 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to 二叉树的遍历模版（递归，迭代）" href=https://allenxuxu.github.io/algorithm/tree-traversal/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[gev] 自定义协议支持</h2></header><section class=entry-content><p>https://github.com/Allenxuxu/gev
gev 是一个轻量、快速的基于 Reactor 模式的非阻塞 TCP 网络库，支持自定义协议，轻松快速搭建高性能服务器。
TCP 为什么会"粘包" TCP 本身就是面向流的协议，就是一串没有界限的数据。所以本质上来说 TCP 粘包是一个伪命题。
TCP 底层并不关心上层业务数据，会套接字缓冲区的实际情况进行包的划分，一个完整的业务数据可能会被拆分成多次进行发送，也可能会将多个小的业务数据封装成一个大的数据包发送（Nagle算法）。
gev 如何优雅处理 gev 通过回调函数 OnMessage 通知用户数据到来，回调函数中会将用户数据缓冲区（ringbuffer）通过参数传递过来。
用户通过对 ringbuffer 操作，来进行数据解包，获取到完整用户数据后再进行业务操作。这样又一个明显的缺点，就是会让业务操作和自定义协议解析代码堆在一起。
所以，最近对 gev 进行了一次较大改动，主要是为了能够以插件的形式支持各种自定义的数据协议，让使用者可以便捷处理 TCP 粘包问题，专注于业务逻辑。
做法如下，定义一个接口 Protocol
// Protocol 自定义协议编解码接口 type Protocol interface { UnPacket(c *Connection, buffer *ringbuffer.RingBuffer) (interface{}, []byte) Packet(c *Connection, data []byte) []byte } 用户只需实现这个接口，并注册到 server 中，当客户端数据到来时，gev 会首先调用 UnPacket 方法，如果缓冲区中的数据足够组成一帧，则将数据解包，并返回真正的用户数据，然后在回调 OnMessage 函数并将数据通过参数传递。
下面，我们实现一个简单的自定义协议插件，来启动一个 Server ：
| 数据长度 n | payload | | 4字节 | n 字节 | // protocol....</p></section><footer class=entry-footer>October 31, 2019&nbsp;·&nbsp;3 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to [gev] 自定义协议支持" href=https://allenxuxu.github.io/open-source/gev-protocol/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Uber Go 风格指南</h2></header><section class=entry-content><p>Uber Go 风格指南 译文：https://github.com/Allenxuxu/uber-go-guide 原文：https://github.com/uber-go/guide/blob/master/style.md 简介 风格是指规范代码的共同约定。风格一词其实是有点用词不当的，因为共同约定的范畴远远不止 gofmt 所做的源代码格式化这些。
本指南旨在通过详尽描述 Uber 在编写 Go 代码中的注意事项（规定）来解释其中复杂之处。制定这些注意事项（规定）是为了提高代码可维护性同时也让工程师们高效的使用 Go 的特性。
这份指南最初由 Prashant Varanasi 和 Simon Newton 编写，目的是让一些同事快速上手 Go 。多年来，已经根据其他人的反馈不断修改。
这份文档记录了我们在 Uber 遵守的 Go 惯用准则。其中很多准则是 Go 的通用准则，其他方面依赖于外部资源：
Effective Go The Go common mistakes guide 所有的代码都应该通过 golint 和 go vet 检查。我们建议您设置编辑器：
保存时自动运行 goimports 自动运行 golint 和 go vet 来检查错误 您可以在这找到关于编辑器设定 Go tools 的相关信息：
https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins
指南 指向接口（interface）的指针 你基本永远不需要一个指向接口的指针。你应该直接将接口作为值传递，因为接口的底层数据就是指针。
一个接口包含两个字段：
类型指针，指向某些特定类型信息的指针。 数据指针。如果存储数据是一个指针变量，那就直接存储。如果存储数据是一个值变量，那就存储指向该值的指针。 如果你需要接口方法来修改这些底层数据，那你必须使用指针。...</p></section><footer class=entry-footer>October 13, 2019&nbsp;·&nbsp;13 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Uber Go 风格指南" href=https://allenxuxu.github.io/go/uber-go-guide/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Go 网络库并发吞吐量测试</h2></header><section class=entry-content><p>https://github.com/Allenxuxu/gev
本文主要测试 gev 网络库和其他三方 Go 网络库以及标准库的吞吐量对比。
测试对象 gev ：一个轻量、快速的基于 Reactor 模式的非阻塞 TCP 网络库 eviop ：evio 的优化版本 evio ：Fast event-loop networking for Go gnet ：eviop 的网络模型替换版本 net 标准库 测试方法 采用陈硕测试 muduo 使用的 ping pong 协议来测试吞吐量。
简单地说，ping pong 协议是客户端和服务器都实现 echo 协议。当 TCP 连接建立时，客户端向服务器发送一些数据，服务器会 echo 回这些数据，然后客户端再 echo 回服务器。这些数据就会像乒乓球一样在客户端和服务器之间来回传送，直到有一方断开连接为止。这是用来测试吞吐量的常用办法。
测试的客户端代码： https://github.com/Allenxuxu/gev/blob/master/benchmarks/client/main.go
测试脚本：https://github.com/Allenxuxu/gev/blob/master/benchmarks/bench-pingpong.sh
主要做两项测试：
单线程单个 work 协程测试，测试并发连接数为 10/100/1000/10000 时的吞吐量 4线程4个 work 协程测试，测试并发连接数为 10/100/1000/10000 时的吞吐量 所有测试中，ping pong 消息的大小均为 4096 bytes，客户端始终是4线程运行。...</p></section><footer class=entry-footer>September 22, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go 网络库并发吞吐量测试" href=https://allenxuxu.github.io/open-source/gev-benchmark/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>开源 gev: Go 实现基于 Reactor 模式的非阻塞 TCP 网络库</h2></header><section class=entry-content><p>gev 轻量、快速的 Golang 网络库 gev 是一个轻量、快速的基于 Reactor 模式的非阻塞 TCP 网络库，支持自定义协议，轻松快速搭建高性能服务器。
为什么有 gev Golang 的 goroutine 虽然非常轻量，但是每启动一个 goroutine 仍需要 4k 左右的内存。读了鸟窝大佬的文章【百万 Go TCP 连接的思考: epoll方式减少资源占用】后，便去研究了了下 evio。
evio 虽然非常快，但是仍然存在一些问题，便尝试去优化它，于是有了 eviop 项目。关于 evio 的问题可以看我的另一篇博文 【Golang 网络库evio一些问题/bug和思考】。在优化 evio 完成 eviop 的过程中，因为其网络模型的缘故，愈加感觉修改它非常麻烦，成本比重新搞一个还高。
最终决定自己重搞一个，更加轻量，不需要的全去掉。加上大学时学习过 muduo ，便参考 muduo 的使用的 Reactor 模型实现 gev 。
在 linux 环境下，gev 底层使用 epoll ，这是 gev 会专注优化的地方。在 mac 下底层使用 kqueue，可能不会过多关注这部分的优化，毕竟很少有用 mac 做服务器的（Windows 环境"暂"不支持）。
特点 基于 epoll 和 kqueue 实现的高性能事件循环 支持多核多线程 动态扩容 Ring Buffer 实现的读写缓冲区 异步读写 SO_REUSEPORT 端口重用支持 支持 WebSocket 支持定时任务，延时任务 支持自定义协议，处理 TCP 粘包 网络模型 gev 只使用极少的 goroutine, 一个 goroutine 负责监听客户端连接，其他 goroutine （work 协程）负责处理已连接客户端的读写事件，work 协程数量可以配置，默认与运行主机 CPU 数量相同。...</p></section><footer class=entry-footer>September 19, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to 开源 gev: Go 实现基于 Reactor 模式的非阻塞 TCP 网络库" href=https://allenxuxu.github.io/open-source/gev/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://allenxuxu.github.io/tags/go/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2021 <a href=https://allenxuxu.github.io/>徐旭 的博客</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>