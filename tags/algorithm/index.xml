<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on 徐旭 的博客</title><link>https://allenxuxu.github.io/tags/algorithm/</link><description>Recent content in algorithm on 徐旭 的博客</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 30 May 2020 11:22:38 +0800</lastBuildDate><atom:link href="https://allenxuxu.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>二叉堆与堆排序</title><link>https://allenxuxu.github.io/algorithm/heap/</link><pubDate>Sat, 30 May 2020 11:22:38 +0800</pubDate><guid>https://allenxuxu.github.io/algorithm/heap/</guid><description>二叉堆是一组能够用堆有序的完全二叉树排序的元素，一般用数组来存储。
大顶堆， 每个结点的值都大于或等于其左右孩子结点的值，其顶部为最大值。
小顶堆，每个结点的值都小于或等于其左右孩子结点的值，其顶部为最小值。
二叉堆 性质 根节点在数组中的位置是 1 左边子节点 2i 右子节点 2i+1 父节点 i / 2 最后一个非叶子节点为 len / 2 根节点在数组中的位置是 0 左子节点 2i + 1 右边子节点 2i+ 2 父节点的下标是 (i − 1) / 2 最后一个非叶子节点为 len / 2 - 1 图片来自知乎
实现 构造二叉堆 找到最后一个非叶子节点 ( len / 2 或者 len / 2 - 1） 从最后一个非叶子节点下标索引开始递减，逐个下沉 插入节点 在数组的最末尾插入新节点 将最后一个节点上浮，时间复杂度为O(log n) 比较当前节点与父节点 不满足 堆性质* *则交换 删除根节点 删除根节点用于堆排序</description></item><item><title>二叉树的遍历模版（递归，迭代）</title><link>https://allenxuxu.github.io/algorithm/tree-traversal/</link><pubDate>Sun, 26 Apr 2020 11:22:38 +0800</pubDate><guid>https://allenxuxu.github.io/algorithm/tree-traversal/</guid><description>图片来自 leetcode
深度优先遍历（dfs） 前序遍历 中序遍历 后序遍历 广度优先遍历（bfs） type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 深度优先遍历 递归 递归版本，代码比较简单，只需改变 append 数据的位置即可。
前序遍历 func preorderTraversal(root *TreeNode) []int { var ret []int helper(root, &amp;amp;ret) return ret } func helper(root *TreeNode, data *[]int) { if root == nil { return } *data = append(*data, root.Val) helper(root.Left, data) helper(root.Right, data) } 中序遍历 func inorderTraversal(root *TreeNode) []int { var ret []int helper(root, &amp;amp;ret) return ret } func helper(root *TreeNode, data *[]int) { if root == nil { return } helper(root.</description></item></channel></rss>