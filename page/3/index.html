<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>徐旭 的博客</title><meta name=description content><meta name=author content="徐旭"><link rel=canonical href=https://allenxuxu.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.min.04512c372388e08b5118f5b117b2d3efef4ddae52017e16085c8d8d4e361c43d.css integrity="sha256-BFEsNyOI4ItRGPWxF7LT7+9N2uUgF+FghcjY1ONhxD0=" rel="preload stylesheet" as=style><link rel=icon href=https://allenxuxu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://allenxuxu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://allenxuxu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://allenxuxu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://allenxuxu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><link rel=alternate type=application/rss+xml href=https://allenxuxu.github.io/index.xml><link rel=alternate type=application/json href=https://allenxuxu.github.io/index.json><meta property="og:title" content="徐旭 的博客"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://allenxuxu.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="徐旭 的博客"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"徐旭 的博客","url":"https://allenxuxu.github.io/","description":"","thumbnailUrl":"https://allenxuxu.github.io/favicon.ico","sameAs":["https://github.com/Allenxuxu","index.xml"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://allenxuxu.github.io/ accesskey=h title="徐旭 的博客 (Alt + H)">徐旭 的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://allenxuxu.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://allenxuxu.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://allenxuxu.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://allenxuxu.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>dokcer swarm 部署go-micro微服务应用</h2></header><section class=entry-content><p>微服务应用使用容器部署非常方便，但是当应用服务注册自身地址(ip:port)到服务注册中心的时候，如果注册的是容器内的ip，别的服务是无法访问到的。
解决这个问题，可以在运行容器的时候指定网络模式为 host (–net=host) ，这样就可以跳过 Docker 的独立网络栈，直接通过本机IP端口就可以访问，但是这样会大量占用本地端口。
最好的场景还是后端服务都在容器网络中，仅 API 网关暴露一个端口供外部访问，但是同时还后端服务还需要能实现跨机器的网络连通。
早期 Docker 本身的容器网络本身并不支持跨机器，也就是说明如果容器部署在不同的节点（服务器）上面，只能通过暴露端口到宿主机上，再通过宿主机之间进行通信。Docker 12.0 之后的版本自带 Docker Swarm，Docker Swarm 的 Overlay 网络驱动可以实现跨主机网络通信。Kubernetes 固然好，但是同时也非常重，学习成本也很大，Swarm 在小项目中还是有用武之地的。
dokcer swarm 集群搭建 准备两台安装有 docker 的机器： 192.168.0.1 192.168.0.2
192.168.0.1 创建master节点
# docker swarm init # docker swarm join \ --token SWMTKN-1-3uu3gjkdt6xgk06wd1c9gfog8xec99ga69ilcclyzyk181n5ki-6f7frw75gvpdwsl1yvpf885lw \ 192.168.0.1:2377 This node joined a swarm as a worker. 复制上面的 docker swarm join … 在 192.168.0.2 上执行，即将本机加入 swarm 集群。
至此，我们已经创建了一个最基础的 swarm 的集群，执行命令查看：
# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS r76ighlnw0p2r0tbd9wmoqaep server2 Ready Active rzqbzl58hlu89xoty4cedn0er * server1 Ready Active Leader 创建 overlay 网络 先创建一个可以跨机器的 overlay 网络...</p></section><footer class=entry-footer>July 18, 2019&nbsp;·&nbsp;2 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to dokcer swarm 部署go-micro微服务应用" href=https://allenxuxu.github.io/posts/docker/docker-swarm/></a></article><article class=post-entry><header class=entry-header><h2>Go Micro hystrix 熔断</h2></header><section class=entry-content><p>hystrix-go hystrix是Netflix开源的一个JAVA项目，不过GitHub也有golang的实现版本hystrix-go
hystrix-dashboard hystrix并没有自带一个仪表盘，无法直观的查看接口的健康状况。所以，我们采用GitHub的一个开源实现hystrix-dashboard。
docker run --name hystrix-dashboard -d -p 8081:9002 mlabouardy/hystrix-dashboard:latest micro API网关插件 关于hystrix的工作原理，可以查阅相关资料，这里只讲解如何封装插件在micro API网关中使用。
err := hystrix.Do("my_command", func() error { // talk to other services return nil }, nil) 使用hystrix.Do() 同步API，第一个参数是command, 应该是与当前请求一一对应的一个名称，如入“GET-/test”。第二个参数传入一个函数，函数包含我我们自己的错误逻辑，当请求失败时应该返回error。hystrix会根据我们的失败率执行熔断策略。
封装Handler // BreakerWrapper hystrix breaker func BreakerWrapper(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { name := r.Method + "-" + r.RequestURI log.Println(name) err := hystrix.Do(name, func() error { sct := &status_code.StatusCodeTracker{ResponseWriter: w, Status: http.StatusOK} h....</p></section><footer class=entry-footer>June 27, 2019&nbsp;·&nbsp;2 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go Micro hystrix 熔断" href=https://allenxuxu.github.io/posts/go-micro/go-micro-hystrix/></a></article><article class=post-entry><header class=entry-header><h2>Go Micro 服务健康检查</h2></header><section class=entry-content><p>服务健康检查 在微服务架构中，每个服务都会存在多个实例，可能部署在不同的主机中。因为网络或者主机等不确定因素，每个服务都可能会出现故障。我们需要能够监控每个服务实例的健康状态，当一个服务故障时，及时将它从注册中心删除。
实现 micro提供两个方法可以直接实现健康检查功能
micro.RegisterTTL(time.Second*30), micro.RegisterInterval(time.Second*20), Interval就是间隔多久服务会重新注册 TTL就是注册服务的过期时间，如果服务挂了，超过过期时间后，注册中心也会将服务删除
micro内部服务注册的流程 当我们执行service.Run() 时内部会执行Start() 在Start函数中又会执行s.opts.Server.Start()，方法的实现在go-micro/server/rpc_server.go中。 我们跳转到内部server的Start方法 可以发现micro使用一个定时器按照间隔时间去自动重新注册。当服务意外故障，无法向注册中心重新注册时，如果超过了设定的TTL时间，注册中心就会将服务删除。
修改源码 service := grpc.NewService( micro.Name("go.micro.srv.hello"), micro.WrapHandler(ocplugin.NewHandlerWrapper(t)), + micro.RegisterTTL(time.Second*15), + micro.RegisterInterval(time.Second*10), // micro.Version("latest"), ) service := web.NewService( web.Name(name), web.Version("lastest"), + web.RegisterTTL(time.Second*15), + web.RegisterInterval(time.Second*10), web.MicroService(grpc.NewService()), )</p></section><footer class=entry-footer>June 27, 2019&nbsp;·&nbsp;1 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go Micro 服务健康检查" href=https://allenxuxu.github.io/posts/go-micro/go-micro-ttl/></a></article><article class=post-entry><header class=entry-header><h2>Golang实现默认参数</h2></header><section class=entry-content><p>在golang 中是不支持默认参数的，micro中有一种优雅的实现方法(并非 micro 首创)，叫做 Functional Options Patter。Functional Options 可以用来实现简洁的支持默认参数的函数方法。
options package server import ( "time" ) type Options struct { ConnectTimeOut time.Duration Name string Address string } type Option func(*Options) func newOptions(opt ...Option) Options { opts := Options{} for _, o := range opt { o(&opts) } if len(opts.Address) == 0 { opts.Address = DefaultAddress } if len(opts.Name) == 0 { opts.Name = DefaultName } if opts.ConnectTimeOut == time.Duration(0) { opts....</p></section><footer class=entry-footer>June 27, 2019&nbsp;·&nbsp;2 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Golang实现默认参数" href=https://allenxuxu.github.io/posts/go/go-options/></a></article><article class=post-entry><header class=entry-header><h2>Go Micro API网管增加 JWT 鉴权</h2></header><section class=entry-content><p>micro API网关 micro API网关是基于go-micro开发的，具有服务发现，负载均衡和RPC通信的能力。
业界普遍做法是将鉴权，限流，熔断等功能也纳入API网关。micro API网关本身是可插拔的，可以通过新增插件的方式加入其他功能。
JWT (JSON Web Token) JWT是是微服务中常用的授权技术，关于JWT的技术原理可以参考阮一峰的博文
JWT库封装 lib/token 目录下封装了JWT的库。有一点特殊的是，库中利用consul的KV存储和micro的go-config库实现了动态更新JWT的PrivateKey功能，实际生产中还是应该使用拥有发布和权限管理的配置中心。 go-config 是micro作者实现的一个可动态加载、可插拔的配置库，可以从多种格式文件或者远程服务获取配置。详情可以参考文档中文文档|英文文档 PrivateKey是JWT在编解码时使用的私钥，一旦泄漏，客户端便可以利用这个私钥篡改、伪造Token。所以一般生产环境中都必须具备动态更新私钥的能力，一旦发现泄漏可以立即更改，或者定期更换私钥，提高安全性。 // InitConfig 初始化 func (srv *Token) InitConfig(address string, path ...string) { consulSource := consul.NewSource( consul.WithAddress(address), ) srv.conf = config.NewConfig() err := srv.conf.Load(consulSource) if err != nil { log.Fatal(err) } value := srv.conf.Get(path...).Bytes() if err != nil { log.Fatal(err) } srv.put(value) log.Println("JWT privateKey:", string(srv.get())) srv.enableAutoUpdate(path...) } func (srv *Token) enableAutoUpdate(path ....</p></section><footer class=entry-footer>June 24, 2019&nbsp;·&nbsp;2 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go Micro API网管增加 JWT 鉴权" href=https://allenxuxu.github.io/posts/go-micro/go-micro-gateway-jwt/></a></article><article class=post-entry><header class=entry-header><h2>Go Micro jaeger 分布式链路追踪</h2></header><section class=entry-content><p>安装jaeger jaeger提供一个all in one 的docker镜像，可以快速搭建实验环境
docker run -d --name jaeger -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 -p 5775:5775/udp -p 6831:6831/udp -p 6832:6832/udp -p 5778:5778 -p 16686:16686 -p 14268:14268 -p 9411:9411 jaegertracing/all-in-one:1.6 OpenTracing OpenTracing通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现。 OpenTracing提供了用于运营支撑系统的和针对特定平台的辅助程序库。 jaeger兼容OpenTracing API，所以我们使用OpenTracing的程序库可以方便的替换追踪工具。 OpenTracing中文文档
jaeger使用 封住一下jaeger的初始化操作方便使用，详细用法可以查看 jaeger-client-go
// lib/tracer // NewTracer 创建一个jaeger Tracer func NewTracer(servicename string, addr string) (opentracing.Tracer, io.Closer, error) { cfg := jaegercfg.Configuration{ ServiceName: servicename, Sampler: &jaegercfg.SamplerConfig{ Type: jaeger.SamplerTypeConst, Param: 1, }, Reporter: &jaegercfg.ReporterConfig{ LogSpans: true, BufferFlushInterval: 1 * time....</p></section><footer class=entry-footer>June 24, 2019&nbsp;·&nbsp;3 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go Micro jaeger 分布式链路追踪" href=https://allenxuxu.github.io/posts/go-micro/go-micro-jaeger/></a></article><article class=post-entry><header class=entry-header><h2>Go Micro 重试机制</h2></header><section class=entry-content><p>在分布式系统中，经常会有服务出现故障，所以良好的重试机制可以大大的提高系统的可用性。本文主要分析micro的客户端重试机制，以及实例演示。
micro 重试实现 micro框架提供方法设置客户端重试的次数。
Client.Init( client.Retries(3), ) 当client请求失败时，客户端会根据selector的策略选择下一个节点重试请求。这样当一个服务实例故障时，客户端可以自动调用另一个实例。
我们来看看micro 客户端内部重试的实现：
go-micro\client\rpc_client.go
func (r *rpcClient) Call(ctx context.Context, request Request, response interface{}, opts ...CallOption) error { ... //客户端call 调用函数， 在下面的循环中调用 call := func(i int) error { // call backoff first. Someone may want an initial start delay t, err := callOpts.Backoff(ctx, request, i) if err != nil { return errors.InternalServerError("go.micro.client", "backoff error: %v", err.Error()) } // only sleep if greater than 0 if t....</p></section><footer class=entry-footer>June 20, 2019&nbsp;·&nbsp;3 min&nbsp;·&nbsp;徐旭</footer><a class=entry-link aria-label="post link to Go Micro 重试机制" href=https://allenxuxu.github.io/posts/go-micro/go-micro-retry/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://allenxuxu.github.io/page/2/>« Prev Page</a></nav></footer></main><footer class=footer><span>&copy; 2021 <a href=https://allenxuxu.github.io/>徐旭 的博客</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>